<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>中国大学生程序设计竞赛（CCPC）2024 网络预选赛 题解</title>
    <url>/2024/09/15/%5B%E9%A2%98%E8%A7%A3%5D%20CCPC%202024/</url>
    <content><![CDATA[<blockquote>
<p>前言： 打一个名额走人！</p>
</blockquote>
<p>补题链接：<a href="https://codeforces.com/gym/105336">The 2024 CCPC
Online Contest</a></p>
<span id="more"></span>
<h4 id="b.-军训-ii">B. 军训 II</h4>
<h6 id="题意">题意</h6>
<p>Siri 的连一共有 n (n &lt;= 1e3) 名同学，其中第 i 名同学的身高为
ai。教官想把他们排成一列，以便练习正步。
教官觉得，如果一个区间内各同学的身高不一致，那么看起来就会不太整齐。他定义了一个序列的<strong>不整齐度</strong>，表示所有区间的身高极差之和，这里极差指的是最大值与最小值的差值。
教官想将这 n
名不同的同学排成一列，使得整个队列的不整齐度最小，同时他还想知道一共有多少种不同的排法。但是，庞大的计算量使得教官无法快速完成这个任务，于是他决定向整个连队中编程水平最高的
Siri 求助。</p>
<h6 id="题解">题解</h6>
<p>使不整齐度最小只需先排列 a
序列，枚举每个区间将极差累加。对于排列方法的计数，可以先求出每个数字出现了多少次，任意交换其顺序都可以，因此答案为每个数字出现次数的阶乘之积。</p>
<p>同时注意，只是整个数组不是同一个数字，反过来排列也可以，需要再乘一个
2。</p>
<p>炫耀一下这个 MInt
板子，易用性和效率都没得说，从蒋老师那里小改了一下。</p>
<h6 id="实现">实现</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> type <span class="title">power</span><span class="params">(type a, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    type res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>) res *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = a * b - <span class="built_in">ll</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) res += p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;ll Mod = <span class="number">998244353</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> MInt</span><br><span class="line">&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="built_in">MInt</span>(ll n = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(n % Mod)) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> ll <span class="title">norm</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) n += Mod;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= Mod) n -= Mod;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, Mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MInt</span>(Mod - x);</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>+=(MInt r) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + r.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>-=(MInt r) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - r.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>*=(MInt r) &amp; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Mod &lt; (<span class="number">1ULL</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">            x = x * r.x % Mod;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">mul</span>(x, r.x, Mod);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>/=(MInt r) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= r.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>+(MInt l, MInt r) &#123;</span><br><span class="line">        l += r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>-(MInt l, MInt r) &#123;</span><br><span class="line">        l -= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>/(MInt l, MInt r) &#123;</span><br><span class="line">        l /= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>*(MInt l, MInt r) &#123;</span><br><span class="line">        l *= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>==(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() == r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>!=(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() != r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() &lt; r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, MInt&amp; r) &#123;</span><br><span class="line">        ll v;</span><br><span class="line">        in &gt;&gt; v;</span><br><span class="line">        r = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> out &lt;&lt; r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MInt&lt;&gt; fab[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fab[<span class="number">0</span>] = MInt&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        fab[i] = fab[i - <span class="number">1</span>] * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; x : a)</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> M = a[i], m = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            M = <span class="built_in">max</span>(M, a[j]);</span><br><span class="line">            m = <span class="built_in">min</span>(m, a[j]);</span><br><span class="line">            ans += M - m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MInt&lt;&gt; cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span> <span class="keyword">or</span> a[i] != a[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            cnt *= fab[c];</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] != a[n - <span class="number">1</span>]) cnt *= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">solve</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="d.-编码器-解码器">D. 编码器-解码器</h4>
<h6 id="题意-1">题意</h6>
<p>limpid 和 S 酱在传输秘密信息，秘密信息可以看成一个数字 x。 S
酱决定将秘密信息 x 编码成一个字符串 S。 而 limpid 决定解密这个 x
是多少。当他知道 S 后，他会将其还原成真正的解码串 S'（n（其中，n
为字符串 S 的长度，即 |S|），具体的还原方式为：</p>
<p>S'i = S'i-1 + a[i] + S'i-1 (i &gt; 1) S'1 = a[1]</p>
<p>其中，ai 表示字符串 S 第 i 个位置上的字符（从 1
开始编号），加号表示拼接运算。 在知道真正的解码串之后，limpid 会根据与 S
酱之前商定好的 T 开始解密，其中 x 为 T 在 S' 中以子序列形式出现的次数。
如果你是 limpid ，告诉你 S, T ，你能帮助他解密得到秘密信息 x 吗。
由于答案可能很大，你只需要输出 x 模 998 244 353 的值即可。</p>
<h6 id="题解-1">题解</h6>
<p>区间 DP，设状态 f[i, l, r] 为 S’i 中 T 的子串 [l, r]
以子序列形式出现的次数。</p>
<p>容易想到对 T[l, r] 中的每个位置 j，如果 T[j] = a[i]，有 f[i - 1, l, j
- 1] * f[i - 1, j + 1, r] 种方案；同时如果不考虑 a[i] 的影响，对每个 [l,
r] 中的分界线 d，还有 f[i - 1, l, d] * f[i - 1, d + 1, r] 种方案。</p>
<p>怎么处理边界情况呢？介绍一个小 tricks，可以把每个满足 l &gt; r 的
f[i, l, r] 都视为 1，这样就可以完美使用上面的转移方程了。</p>
<p>又用到了这个 MInt 模板：）</p>
<h6 id="实现-1">实现</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> type <span class="title">power</span><span class="params">(type a, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    type res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>) res *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = a * b - <span class="built_in">ll</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) res += p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;ll Mod = <span class="number">998244353</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> MInt</span><br><span class="line">&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="built_in">MInt</span>(ll n = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(n % Mod)) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> ll <span class="title">norm</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) n += Mod;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= Mod) n -= Mod;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, Mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MInt</span>(Mod - x);</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>+=(MInt r) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + r.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>-=(MInt r) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - r.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>*=(MInt r) &amp; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Mod &lt; (<span class="number">1ULL</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">            x = x * r.x % Mod;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">mul</span>(x, r.x, Mod);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>/=(MInt r) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= r.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>+(MInt l, MInt r) &#123;</span><br><span class="line">        l += r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>-(MInt l, MInt r) &#123;</span><br><span class="line">        l -= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>/(MInt l, MInt r) &#123;</span><br><span class="line">        l /= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>*(MInt l, MInt r) &#123;</span><br><span class="line">        l *= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>==(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() == r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>!=(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() != r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() &lt; r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, MInt&amp; r) &#123;</span><br><span class="line">        ll v;</span><br><span class="line">        in &gt;&gt; v;</span><br><span class="line">        r = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> out &lt;&lt; r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MInt&lt;&gt; f[N][N][N] &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s, t = <span class="string">&#x27; &#x27;</span> + t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= m + <span class="number">1</span>; k++)</span><br><span class="line">                <span class="keyword">if</span> (j &gt; k) f[i][j][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= m; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> d = j; d &lt;= k; d++)</span><br><span class="line">                    <span class="keyword">if</span> (s[i] == t[d])</span><br><span class="line">                        f[i][j][k] += f[i - <span class="number">1</span>][j][d - <span class="number">1</span>] * f[i - <span class="number">1</span>][d + <span class="number">1</span>][k];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> d = j - <span class="number">1</span>; d &lt;= k; d++)</span><br><span class="line">                    f[i][j][k] += f[i - <span class="number">1</span>][j][d] * f[i - <span class="number">1</span>][d + <span class="number">1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; f[n][<span class="number">1</span>][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="e.-随机过程">E. 随机过程</h4>
<h6 id="题意-2">题意</h6>
<p>S 酱随机了 n 个长度为 m 的字符串，具体随机过程为对于第 i 个串的第 j
位在 a ∼ z 等概率随机一个。 S 酱想知道将这 n
个串插入字典树后（即对于字典树中任意的叶子节点，存在这 n
个串中的某一个串使
得与该叶子代表的字符串相等），字典树上节点个数的最大值与期望。
由于答案可能很大，你需要输出答案对 998 244 353 取模后的结果。
请注意：对于求最多有多少个结点，不是求答案在模 998 244 353
意义下的最大值，而是最大值对 998 244 353 取模后的结果。</p>
<h6 id="题解-2">题解</h6>
<p>很容易得到最大结点数 $ _{i=0}^{m} min(n, 26^i) $
，接下来讨论结点数的期望。</p>
<p>每一层的所有节点出现在 Trie 中的期望是一样的，考虑计算第 i
层某个特定点不出现的概率，为 $ p_i = (1 - 1 / 26^i )^n $。因此答案为 $
_{i=0}^{m} (1-p_i) ^i $。</p>
<h6 id="实现-2">实现</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iso646.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> type <span class="title">power</span><span class="params">(type a, ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    type res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>) res *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = a * b - <span class="built_in">ll</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) res += p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;ll Mod = <span class="number">998244353</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> MInt</span><br><span class="line">&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="built_in">MInt</span>(ll n = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(n % Mod)) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> ll <span class="title">norm</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) n += Mod;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= Mod) n -= Mod;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, Mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MInt</span>(Mod - x);</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>+=(MInt r) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + r.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>-=(MInt r) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - r.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>*=(MInt r) &amp; &#123;</span><br><span class="line">        <span class="keyword">if</span> (Mod &lt; (<span class="number">1ULL</span> &lt;&lt; <span class="number">31</span>))</span><br><span class="line">            x = x * r.x % Mod;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">mul</span>(x, r.x, Mod);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MInt&amp; <span class="keyword">operator</span>/=(MInt r) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= r.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>+(MInt l, MInt r) &#123;</span><br><span class="line">        l += r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>-(MInt l, MInt r) &#123;</span><br><span class="line">        l -= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>/(MInt l, MInt r) &#123;</span><br><span class="line">        l /= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>*(MInt l, MInt r) &#123;</span><br><span class="line">        l *= r;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>==(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() == r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> MInt <span class="keyword">operator</span>!=(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() != r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(MInt l, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">val</span>() &lt; r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, MInt&amp; r) &#123;</span><br><span class="line">        ll v;</span><br><span class="line">        in &gt;&gt; v;</span><br><span class="line">        r = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MInt r) &#123;</span><br><span class="line">        <span class="keyword">return</span> out &lt;&lt; r.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    MInt&lt;&gt; ans1 = <span class="number">1</span>, c26 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c26 *= <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; c26 <span class="keyword">or</span> flag) &#123;</span><br><span class="line">            ans1 += n;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans1 += c26;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MInt&lt;&gt; ans2 = <span class="number">1</span>;</span><br><span class="line">    c26 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c26 *= <span class="number">26</span>;</span><br><span class="line">        ans2 += (<span class="number">1</span> - <span class="built_in">power</span>(<span class="number">1</span> - c<span class="number">26.</span><span class="built_in">inv</span>(), n)) * c26;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="g.-疯狂星期六">G. 疯狂星期六</h4>
<h6 id="题意-3">题意</h6>
<p>yyq 和他的朋友们一共 n 个人（编号为 1 到 n ，yyq 编号为
1）去某饭店吃疯狂星期六。第 i 个人初始手中有 ai
元的零花钱，即每个人的总花费不能超过 ai
元。由于每个人到饭店的路程不同，所以第 i 个人打车去的花费为 Vi 元。 yyq
和他的朋友们一共点了 m 件菜品。其中，第 i 件菜品价值 Wi 元，由第 xi
个人和第 yi 个人吃。结账的时候，xi 和 yi
可以自行决定他们俩谁付多少钱（要求每个人在这道菜中付的钱为非负整数，且
xi 和 yi 付款的和必须为 Wi 元）。由于今天是 yyq 的生日，所以 yyq
想让自己的总花费（打车费与菜品费之和）最多，即严格大于其他每个人的总花费。
请问在每个人不超额花费的前提下， yyq 的愿望能实现吗？ 注意 xi 和 yi
可能相等，即一个人独吃这道菜，这个人独自付该菜品费用。</p>
<h6 id="题解-3">题解</h6>
<p>网络流。很容易得到 yyq
的最大花费，由此得到每个人在菜品上的最大花费，然后这样建一个二分图：</p>
<ul>
<li>从源点向所有菜品连一条权重为其价格 w 的边；</li>
<li>从菜品向对应的两个人各连一条权重为其价格 w 的边；</li>
<li>从每个人向汇点连一条权重为其最大花费的边；</li>
<li>从源点向汇点连一条权重为 yyq 在菜品上花费的边。</li>
</ul>
<p>问题转换为是否存在合法解，合法解判定条件为：最大流 = 菜品总价格。</p>
<p>再次向您兜售世界上最伟大的 Dinic 算法求最大流模板：）</p>
<h6 id="实现-3">实现</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MaxFlow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Edge</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        T cap;</span><br><span class="line">        _Edge(<span class="type">int</span> to, T cap) : <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;_Edge&gt; e;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cur, h;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MaxFlow</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">MaxFlow</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        e.<span class="built_in">clear</span>();</span><br><span class="line">        g.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">        cur.<span class="built_in">resize</span>(n);</span><br><span class="line">        h.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        h.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        h[s] = <span class="number">0</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : g[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> [v, c] = e[i];</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t, T f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t) <span class="keyword">return</span> f;</span><br><span class="line">        T r = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i &lt; g[u].<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> j = g[u][i];</span><br><span class="line">            <span class="keyword">auto</span> [v, c] = e[j];</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                T a = <span class="built_in">dfs</span>(v, t, <span class="built_in">min</span>(r, c));</span><br><span class="line">                e[j].cap -= a;</span><br><span class="line">                e[j ^ <span class="number">1</span>].cap += a;</span><br><span class="line">                r -= a;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f - r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, T c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(v, c);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">flow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t))</span><br><span class="line">        &#123;</span><br><span class="line">            cur.<span class="built_in">assign</span>(n, <span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">dfs</span>(s, t, numeric_limits&lt;T&gt;::<span class="built_in">max</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pnn = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;pnn&gt; <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [a, v] = p[i];</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll yyq = p[<span class="number">1</span>].second, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s = n + m + <span class="number">1</span>, t = s + <span class="number">1</span>;</span><br><span class="line">    <span class="function">MaxFlow&lt;ll&gt; <span class="title">g</span><span class="params">(t + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">1</span> <span class="keyword">or</span> v == <span class="number">1</span>) yyq += w;</span><br><span class="line">        g.<span class="built_in">addEdge</span>(s, n + i, w);</span><br><span class="line">        g.<span class="built_in">addEdge</span>(n + i, u, w);</span><br><span class="line">        g.<span class="built_in">addEdge</span>(n + i, v, w);</span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    yyq = <span class="built_in">min</span>(yyq, (ll)p[<span class="number">1</span>].first);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">1</span>, t, yyq - p[<span class="number">1</span>].second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [a, v] = p[i];</span><br><span class="line">        a = <span class="built_in">min</span>((ll)a, yyq - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a &lt; v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        g.<span class="built_in">addEdge</span>(i, t, a - v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g.<span class="built_in">flow</span>(s, t) == sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">judge</span>(n, m) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="k.-取沙子游戏">K. 取沙子游戏</h4>
<h6 id="题意-4">题意</h6>
<p>Alice 和 Bob 在玩取沙子游戏，一共有 n 粒沙子。 两人轮流取沙子，Alice
先取。每个人要求取的数量不能超过
k，且必须为前面所有取的沙子数量的公因数（包括对手的）。特别地，Alice
第一次取沙子时，沙子个数不受第二条限制，即不超过 k 即可。
先取完这些沙子的人获胜。Alice 想知道，若在两人都绝对聪明的情况下，Alice
是否可以获胜。</p>
<h6 id="题解-4">题解</h6>
<p>重头戏结束了，来点轻松愉快的博弈。先手必胜的充分必要条件为第一次能取到
lowbit(n) 个沙子。</p>
<h6 id="实现-4">实现</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &gt;= (n &amp; -n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n, k;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; (<span class="built_in">judge</span>(n, k) ? <span class="string">&quot;Alice&quot;</span> : <span class="string">&quot;Bob&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="l.-网络预选赛">L. 网络预选赛</h4>
<h6 id="题解-5">题解</h6>
<p>本场签到，枚举所给矩阵的每个子矩阵然后直接暴力判断即可。</p>
<h6 id="实现-5">实现</h6>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (string&amp; d : s)</span><br><span class="line">        cin &gt;&gt; d;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;c&#x27;</span> <span class="keyword">and</span> s[i - <span class="number">1</span>][j] == <span class="string">&#x27;c&#x27;</span> <span class="keyword">and</span> s[i][j - <span class="number">1</span>] == <span class="string">&#x27;p&#x27;</span> <span class="keyword">and</span> s[i][j] == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s ACM</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 1：内存空间配置</title>
    <url>/2024/08/28/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%971/</url>
    <content><![CDATA[<p>STL（标准模板库，Standard Template Library）是 C++
标准库最重要的组成部分，包含了一系列算法与数据结构的可复用组件，分为六大组件
allocator, container, iterator, algorithms, functor, adapter。</p>
<p>作为一个
ACMer，笔者一直想补足这部分比赛中不涉及的内容。首先参考侯捷先生所著《STL源码剖析》开发一款我们自己的
allocator，用于后续开发过程中的内存空间配置管理。</p>
<p>在 STL 中，负责该部分的头文件为
&lt;memory&gt;，事实上分为三个主要的组成部分。</p>
<span id="more"></span>
<h4 id="一tiny_construct.h">一、tiny_construct.h</h4>
<p>提供两个全局函数 construct 与 destroy，单独负责构造与析构对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span>          <span class="comment">// for placement new</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span>(p) <span class="built_in">T1</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">(T* pointer)</span> </span>&#123;</span><br><span class="line">    pointer-&gt;~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">    _destory(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> _destory(ForwardIterator first, ForwardIterator last, T*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> trivial_destructor = __type_traits&lt;T&gt;::has_trivial_destructor;</span><br><span class="line">    __destroy_aux(first, last, <span class="built_in">trivial_destructor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">        <span class="built_in">destroy</span>(&amp;*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForWardIterator&gt;</span><br><span class="line"><span class="type">void</span> __destroy_aux(ForWardIterator first, ForWardIterator last, __true_type) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">wchar_t</span>*, <span class="type">wchar_t</span>*)</span> </span>&#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="二tiny_alloc.h">二、tiny_alloc.h</h4>
<p>提供两层内存配置器 default_alloc 与
malloc_alloc，单独负责空间的配置，由宏定义 __USE_MALLOC
决定是否采用第二层 allocator。</p>
<p>这里不得不讨论以下两个标准内存管理工具的区别，即 c 语言标准库提供的
malloc()函数 与 c++ 标准库提供的 new 运算符。malloc()
只负责向操作系统申请内存，但 new 会在申请的内存上调用构造函数。</p>
<p>这看似没什么问题，平时的编程也会鼓励使用 new
构造对象，但这在需要构造的对象很小而很频繁时会有不可忽略的开销。因此 SGI
STL 的设计是，将内存的分配和对象的构造分开，利用 placement new
在已经申请的空间上构造对象（上一小节的 construct 函数）。</p>
<p>具体地说，当申请的内存足够大时（大于 128 bytes），进入第一层
alloc，直接向操作系统申请内存：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">volatile</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span> </span>= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span>*, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">void</span>* result = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">nullptr</span>)</span><br><span class="line">            result = <span class="built_in">oom_malloc</span>(n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">reallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span>, <span class="type">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">void</span> *result = <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">nullptr</span>)</span><br><span class="line">            result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">set_malloc_handler</span><span class="params">(<span class="type">void</span> (*f)())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">void</span> (*old)() = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = f;</span><br><span class="line">        <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (*my_malloc_handler)();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (my_malloc_handler == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> bad_alloc;</span><br><span class="line">        <span class="built_in">my_malloc_handler</span>();</span><br><span class="line">        <span class="type">void</span>* result = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* __malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span>* p, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (*my_malloc_handler)();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (my_malloc_handler == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> bad_alloc;</span><br><span class="line">        <span class="built_in">my_malloc_handler</span>();</span><br><span class="line">        <span class="type">void</span>* result = <span class="built_in">realloc</span>(p, n);</span><br><span class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> malloc_alloc = __malloc_alloc_template&lt;<span class="number">0</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>但当申请的内存足够小时，进入第二层 alloc，使用内存池（memory
pool）分配内存。具体地说，维护几个空白区块链表（free chunk
list），只分配并回收 8 bytes
倍数的内存块，每个链表中维护的区块大小相同。对于链表本身需要的空间，我们用类似链接管理磁盘的方式，让区块前四个字节存储下个区块的地址。C
语言中有一种量身定做的数据结构：union，只需要这样声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非常天才做法，使我的区块自己充当结点</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">    obj* free_list_link;</span><br><span class="line">    <span class="type">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回收内存时，在对应链表头部插入这个区块。分配内存时，取出对应链表头部的区块。如果区块不够了，由
allocate - refill - chunk_alloc
的调用链填充新区块。考虑多线程环境下的使用，需要额外注意 free list
的线程安全问题，详见具体实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> __ALIGN = <span class="number">8</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> __MAX_BYTES = <span class="number">128</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> __NFREELISTS = __MAX_BYTES / __ALIGN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">        obj* free_list_link;</span><br><span class="line">        <span class="type">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span>* start_free = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span>* end_free = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> heap_size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> obj* <span class="keyword">volatile</span> free_list[__NFREELISTS] &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (bytes + __ALIGN - <span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (bytes + __ALIGN - <span class="number">1</span>) / __ALIGN - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">reallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> old_sz, <span class="type">size_t</span> new_sz)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>* p, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">allocate</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; __MAX_BYTES)</span><br><span class="line">        <span class="keyword">return</span> malloc_alloc::<span class="built_in">allocate</span>(n);</span><br><span class="line">    </span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    obj* result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));</span><br><span class="line">    </span><br><span class="line">    *my_free_list = result -&gt; free_list_link;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">deallocate</span>(<span class="type">void</span>* p, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; __MAX_BYTES) &#123;</span><br><span class="line">        malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    obj* q = (obj*)p;</span><br><span class="line">    q -&gt; free_list_link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* chunk = <span class="built_in">chunk_alloc</span>(n, nobjs);</span><br><span class="line">    <span class="keyword">if</span> (nobjs == <span class="number">1</span>) <span class="keyword">return</span> chunk;</span><br><span class="line"></span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    obj* result = (obj*)chunk;</span><br><span class="line">    obj* next_obj = *my_free_list = (obj*)(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        obj* current_obj = next_obj;</span><br><span class="line">        <span class="keyword">if</span> (nobjs == i + <span class="number">1</span>) &#123;</span><br><span class="line">            current_obj -&gt; free_list_link = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        next_obj = (*obj)((<span class="type">char</span>*)next_obj + n);</span><br><span class="line">        current_obj -&gt; free_list_link = next_obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> total_bytes = size * nobjs;</span><br><span class="line">    <span class="type">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        <span class="type">char</span>* result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left &gt;= size;</span><br><span class="line">        total_bytes = size * nobjs;</span><br><span class="line">        <span class="type">char</span>* result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        obj* <span class="keyword">volatile</span> * my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">        (obj*)start_free -&gt; free_list_link = *my_free_list;</span><br><span class="line">        *my_free_list = (obj*)start_free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> bytes_to_get = total_bytes * <span class="number">2</span> + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    start_free = (<span class="type">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">    <span class="keyword">if</span> (start_free == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">            obj* <span class="keyword">volatile</span> * my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">            obj* p = *my_free_list;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                *my_free_list = p-&gt;free_list_link;</span><br><span class="line">                start_free = (<span class="type">char</span>*)p;</span><br><span class="line">                end_free = start_free + i;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">chunk_alloc</span>(size, nobjs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start_free = (<span class="type">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line">    end_free = start_free + bytes_to_get;</span><br><span class="line">    heap_size += bytes_to_get;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chunk_alloc</span>(size, nobjs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using default_alloc = __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt;;</span></span><br><span class="line"><span class="keyword">using</span> default_alloc = __default_alloc_template&lt;<span class="literal">true</span>, <span class="number">0</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>其中最复杂的部分是
chunk_alloc，依次处理内存非常充足、内存剩余不多、无法申请内存与无法处理申请内存问题等极端情况，在内存池放水后递归调用自身以降低复杂程度。如果山穷水尽，到处都没内存可用了，还要尝试回到第一级配置器中。</p>
<p>以上就是 allocator 的全部设计。这是 STL
在管理内存时如此高效的原因，将问题分解为多个层次，减少了向操作系统申请内存的次数，大大提高了效率。例如游戏中的粒子效果，一瞬间有上万个对象创建与销毁，在这种应用场景下，使用两级内存配置器的优势是十分显著的。</p>
<h4 id="三tiny_uninitialized.h">三、tiny_uninitialized.h</h4>
<p>除此之外，还要为 container
的实现打一些基础，处理未初始化内存空间。在这个头文件中，提供三个全局函数
uninitialized_fill(), uninitialized_copy(),
uninitialized_fill_n()，同时使用 traits 编程技巧与迭代器的交互。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>              <span class="comment">// for memmove()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_construct.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function uninitialized_fill_n()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Size, <span class="keyword">typename</span> T&gt;</span><br><span class="line">ForwardIterator __uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __true_type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fill_n</span>(first, n, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Size, <span class="keyword">typename</span> T&gt;</span><br><span class="line">ForwardIterator __uninitialized_fill_n_aux(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(&amp;*cur, x);</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Size, <span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line">ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x, T1*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> is_POD = __type_traits&lt;T1&gt;::is_POD_type;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, <span class="built_in">is_POD</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Size, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function uninitialized_copy()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line">ForwardIterator __uninitialized_copy_aux(InputIterator first, InputIterator last, ForwardIterator result, __true_type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">copy</span>(first, last, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line">ForwardIterator __uninitialized_copy_aux(InputIterator first, InputIterator last, ForwardIterator result, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">    ForwardIterator cur = result;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; first++) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(&amp;*cur, *first);</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line">ForwardIterator __uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result, T*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> is_POD = __type_traits&lt;T&gt;::is_POD_type;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy_aux(first, last, result, <span class="built_in">is_POD</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function">ForwardIterator <span class="title">uninitialized_copy</span><span class="params">(InputIterator first, InputIterator last, ForwardIterator result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy(first, last, result, <span class="built_in">value_type</span>(result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* first, <span class="type">const</span> <span class="type">char</span>* last, <span class="type">char</span>* result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memmove</span>(result, first, last - first);</span><br><span class="line">    <span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">wchar_t</span>* <span class="title">uninitialized_copy</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* first, <span class="type">const</span> <span class="type">wchar_t</span>* last, <span class="type">wchar_t</span>* result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memmove</span>(result, first, (last - first) * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line">    <span class="keyword">return</span> result + (last - first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function uninitialized_fill()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x, __true_type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fill</span>(first, last, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x, __false_type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">        <span class="built_in">construct</span>(&amp;*first, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="type">void</span> __uninitialized_fill(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x, T1*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> is_POD = __type_traits&lt;T1&gt;::is_POD_type;</span><br><span class="line">    __uninitialized_fill_aux(first, last, x, <span class="built_in">is_POD</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first, ForwardIterator last, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __uninitialized_fill(first, last, x, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 2：traits 编程与迭代器开发</title>
    <url>/2024/08/29/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%972/</url>
    <content><![CDATA[<p>可能有细心的读者发现，上一篇文章的 tiny_construct.h 与
tiny_uninitialized.h 中出现了一些奇特的类型：__type_traits&lt;&gt;,
__true_type, __false_type。</p>
<p>其实这属于一种称为 traits 编程（意为“类型萃取”）的技巧，利用 C++
template
的类型推导机制与函数重载规则在编译期解决类型识别的问题，有助于根据不同类型选择调用的函数（详见函数
uninitialized_fill() 的实现），弥补 C++ 弱类型的缺陷。</p>
<p>利用这种机制，还能帮助我们开发 stl 中的 iterator（迭代器），为
container（容器）准备最后一块拼图。当然需要用到大量 C++
泛型编程的技巧，以下逐一进行讲解。</p>
<span id="more"></span>
<h4 id="一tiny_type_traits.h">一、tiny_type_traits.h</h4>
<p>首先我们需要两个类型而不是两个值标示 true 与
false，在这里声明两个空的结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__false_type</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>我们希望程序可以这样判断类型 T
是否有以下五个性质，用他们的类型进行参数推导：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor</span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br></pre></td></tr></table></figure>
<p>因此我们先用最保守的方法定义 __type_traits，然后为每个 C++
类型定制适当的实例化版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> __this_dummy_member_must_be_first = __true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor = __false_type; </span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructor = __false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator = __false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor = __false_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type = __false_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;<span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor = __true_type; </span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructor = __true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator = __true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor = __true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type = __true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 为每个原生类型提供自己的 __type_traits （已省略）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor = __true_type; </span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructor = __true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator = __true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor = __true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type = __true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样针对不同的类型属性，我们在编译期完成函数派送决定，例如对全局函数
copy()，根据类型是否有 has_trivial_constructor
性质，帮助我们确定能不能用最高效的 memmove() 或
memcpy()。然后根据这些性质，提供更多的特化与强化版本。</p>
<p>作为该版本 TinySTL 的用户，你还能更好的利用这个
__type_traits。如果编译器支持，对每个类型 T
“萃取”出的性质将与实际声明相同，否则你也可以声明自己的
__type_traits<T>。对于 iterator，traits 编程还将发挥更大的作用。</p>
<h4 id="二tiny_iterator.h">二、tiny_iterator.h</h4>
<p>出于最简单的直觉，每个 container 的开发者需要自行开发对应的
iterator，笔者本人在开发一个简单的贪吃蛇小游戏时，仿照 STL
的接口设计实现了双向队列类
Deque，但在开发迭代器时犯了难，源程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下，省略了各方法的具体实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>		<span class="comment">// double-ended queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		type data;</span><br><span class="line">		Node* prev;</span><br><span class="line">		Node* next;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">Node</span>() : <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">		<span class="built_in">Node</span>(<span class="type">const</span> type&amp; _dta, Node* _prv = <span class="literal">nullptr</span>, Node* _nxt = <span class="literal">nullptr</span>)</span><br><span class="line">			: <span class="built_in">data</span>(_dta), <span class="built_in">prev</span>(_prv), <span class="built_in">next</span>(_nxt) &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	Node* head;</span><br><span class="line">	Node* tail;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Handle</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Node* ptr;</span><br><span class="line">		<span class="built_in">Handle</span>(Node* p = <span class="literal">nullptr</span>) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Deque</span>;</span><br><span class="line">		type <span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ptr-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">		type* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;ptr-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Handle&amp; p) <span class="type">const</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ptr == p.ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Handle&amp; p) <span class="type">const</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> !(*<span class="keyword">this</span> == p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">void</span> <span class="keyword">operator</span>++() &#123;</span><br><span class="line">			ptr = ptr-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">void</span> <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">			ptr = ptr-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">void</span> <span class="keyword">operator</span>--() &#123;</span><br><span class="line">			ptr = ptr-&gt;prev;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">Deque</span>();</span><br><span class="line">	~<span class="built_in">Deque</span>();</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">type <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">type <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">Handle <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function">Handle <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> type&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> type&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以现在的标准看，迭代器 Handle
的设计显然不算优秀。不支持随机访问，不支持通过迭代器对内容进行修改（非常间接，还返回了实际地址的指针），不支持返回引用，不支持得到两个迭代器的距离，不支持获取其指向的类型，最大的作用是兼容
C++11 的按范围 For 循环。</p>
<p>为了解决以上问题，除了用更高级的数据结构之外，我们要求每个 iterator
以内嵌类型定义的形式给出其五个性质：category, value_type,
difference_type, reference, pointer。我们将提供同名函数，基于 traits
编程“萃取”出它的性质，例如 value_type(iterator) 将返回一个指向
iterator::value_type 类型的空指针，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span></span><br><span class="line"><span class="function">    -&gt; iterator_traits&lt;Iterator&gt;::iterator_category</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">category</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span></span><br><span class="line"><span class="function">    -&gt; iterator_traits&lt;Iterator&gt;::difference_type*</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span></span><br><span class="line"><span class="function">    -&gt; iterator_traits&lt;Iterator&gt;::value_type*</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 iterator_traits&lt;&gt; 类似于上一小节的
type_traits&lt;&gt;，如果不能萃取出 iterator 的性质，我们甚至难以得到
iterator 指向什么类型的元素。这里着重讨论性质 category，众所周知
iterator 分为以下五类：input, output, forward, bidirectional, random
access。以 advance() 函数为例，random access iterator
就不需要一步一步前进了，可以在 O(1)
以内到达指定位置。给出如下继承关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirection_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirection_iterator_tag &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>无法给出内嵌类型声明的原生指针，与产生歧义的 const
原生指针，我们给出实例化版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> Iterator::iterator_category;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Iterator::value_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> Iterator::difference;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> Iterator::pointer;</span><br><span class="line">    <span class="keyword">using</span> referencce = <span class="keyword">typename</span> Iterator::reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer = T*</span><br><span class="line">    <span class="keyword">using</span> referencce = T&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="type">const</span> T*</span><br><span class="line">    <span class="keyword">using</span> referencce = <span class="type">const</span> T&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么 iterator_traits<iterator>::iterator_category()
将生成一个临时空结构体对象，没有任何开销，但可以用于推导实际调用的函数，distance()
函数同理。</p>
<p>这样甚至可以避免写出单独用于跳转的函数，只需要写出几个重载的模板函数，进一步提高了效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterator methods: distance()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">auto</span> __distance(InputIterator first, InputIterator last, input_iterator_tag) </span><br><span class="line">    -&gt; iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != last)</span><br><span class="line">        first++, n++;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">auto</span> __distance(InputIterator first, InputIterator last, random_access_iterator_tag) </span><br><span class="line">    -&gt; iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">distance</span><span class="params">(InputIterator first, InputIterator last)</span> </span></span><br><span class="line"><span class="function">    -&gt; iterator_traits&lt;InputIterator&gt;::difference_type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> category = <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::iterator_category;</span><br><span class="line">    <span class="keyword">return</span> __distance(first, last, <span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator methods: advance()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">        i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> __advance(BidirectionalIterator&amp; i, Distance n, bidirection_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (n--) i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span> (n--) i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> __advance(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    i += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __advance(i, n, <span class="built_in">iterator_category</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器的作者开发其专属迭代器时，只需要继承自以下类型即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Category, <span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>, </span><br><span class="line">          <span class="keyword">typename</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt;</span><br><span class="line"><span class="keyword">struct</span> iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = Category;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type = Distance;</span><br><span class="line">    <span class="keyword">using</span> pointer = Pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = Reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上就是 iterator
的全部设计。这只不过是冰山一角，真正的问题还会在在开发具体容器时出现，但作为一种设计思想，这已经足够了。</p>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 3-1：动态数组 vector</title>
    <url>/2024/08/31/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%973-1/</url>
    <content><![CDATA[<p>相比 C++ 语言提供的静态数组 array&lt;&gt;，动态数组 vector&lt;&gt;
更有实用价值，也是对之前 allocator 与 iterator
的第一重考验。我们需要维护一块连续的线性空间，提供 push_back(),
pop_back(), insert(), erase(), resize(), assign()
等需要重新配置内存与迭代器的方法。</p>
<p>最关键的是 vector
对大小的控制和内存重新分配的策略，具体实施起来，是一个 申请新空间 -&gt;
移动数据 -&gt; 释放旧空间 -&gt; 配置迭代器
的大工程。本次参考的仍然是侯捷先生所著的《STL
源码剖析》，遗憾的是，智者千虑必有一失，他给出 insert()
的注释也有些小小的纰漏，其实搬运旧数据并不是一次性完成的。</p>
<span id="more"></span>
<h4 id="实现">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_construct.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_alloc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_uninitialized.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">    <span class="keyword">using</span> iterator = value_type*;</span><br><span class="line">    <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> data_allocator = simple_alloc&lt;value_type, Alloc&gt;;</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    iterator end_of_storage;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        iterator result = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_fill_n</span>(result, n, x);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">        start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">        finish = start + n;</span><br><span class="line">        end_of_storage = finish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">end</span>() - <span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> end_of_storage - <span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>() : <span class="built_in">start</span>(<span class="literal">nullptr</span>), <span class="built_in">finish</span>(<span class="literal">nullptr</span>), <span class="built_in">end_of_storage</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123;  <span class="built_in">fill_initialize</span>(n, <span class="built_in">T</span>()); &#125;</span><br><span class="line">    <span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">    <span class="built_in">vector</span>(vector&amp;);</span><br><span class="line">    <span class="built_in">vector</span>(vector&amp;&amp;);</span><br><span class="line">    ~<span class="built_in">vector</span>() &#123; </span><br><span class="line">        <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">deallocate</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">    <span class="built_in">vector</span>(InputIterator first, InputIterator last);</span><br><span class="line"></span><br><span class="line">    vector&amp; <span class="keyword">operator</span>=(vector&amp;);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator postion, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator postion, size_type, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">            <span class="built_in">construct</span>(finish, x);</span><br><span class="line">            finish++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        finish--;</span><br><span class="line">        <span class="built_in">destroy</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">            <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position);</span><br><span class="line">        finish--;</span><br><span class="line">        <span class="built_in">destroy</span>(finish);</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        iterator i = <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">        <span class="built_in">destroy</span>(i, finish);</span><br><span class="line">        finish -= last - first;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">            <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - <span class="built_in">size</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">vector&lt;T, Alloc&gt;::<span class="built_in">vector</span>(vector&amp; x)</span><br><span class="line">    : <span class="built_in">vector</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>()) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">vector&lt;T, Alloc&gt;::<span class="built_in">vector</span>(vector&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    start = x.start;</span><br><span class="line">    finish = x.finish;</span><br><span class="line">    end_of_storage = x.end_of_storage;</span><br><span class="line">    x.start = <span class="literal">nullptr</span>;</span><br><span class="line">    x.finish = <span class="literal">nullptr</span>;</span><br><span class="line">    x.end_of_storage = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">vector&lt;T, Alloc&gt;::<span class="built_in">vector</span>(InputIterator first, InputIterator last)</span><br><span class="line">&#123;</span><br><span class="line">    size_type len = <span class="built_in">distance</span>(first, last);</span><br><span class="line">    iterator result = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    start = result;</span><br><span class="line">    finish = start + len;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; first++) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(result, *first);</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">vector&lt;T, Alloc&gt;&amp; vector&lt;T, Alloc&gt;::<span class="keyword">operator</span>=(vector&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    iterator first = x.<span class="built_in">begin</span>();</span><br><span class="line">    iterator last = x.<span class="built_in">end</span>();</span><br><span class="line">    size_type len = <span class="built_in">distance</span>(first, last);</span><br><span class="line">    iterator result = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    start = result;</span><br><span class="line">    finish = start + len;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">        <span class="built_in">construct</span>(result, *first);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">swap</span>(vector&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(start, x.start);</span><br><span class="line">    std::<span class="built_in">swap</span>(finish, x.finish);</span><br><span class="line">    std::<span class="built_in">swap</span>(end_of_storage, x.end_of_storage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">assign</span>(size_type n, <span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">        finish = <span class="built_in">uninitialized_fill_n</span>(<span class="built_in">begin</span>(), n, x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator new_start = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_fill_n</span>(new_start, n, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, <span class="type">const</span> T&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, finish - <span class="number">1</span>, finish);</span><br><span class="line">        *position = x;</span><br><span class="line">        finish++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> size_type len = old_size ? old_size * <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        <span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">        new_finish++;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (end_of_storage - finish &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> size_type elems_after = finish - position;</span><br><span class="line">        iterator old_finish = finish;</span><br><span class="line">        <span class="keyword">if</span> (elems_after &gt; n) &#123;</span><br><span class="line">            <span class="built_in">uninitialized_copy</span>(finish - n, finish, finish);</span><br><span class="line">            <span class="built_in">copy_backward</span>(position, finish - n, finish);</span><br><span class="line">            <span class="built_in">fill</span>(position, position + n, x);</span><br><span class="line">            finish += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">uninitialized_fill_n</span>(finish, n - elems_after, x);</span><br><span class="line">            finish += n - elems_after;</span><br><span class="line">            <span class="built_in">uninitialized_copy</span>(position, old_finish, finish);</span><br><span class="line">            finish += elems_after;</span><br><span class="line">            <span class="built_in">fill</span>(position, old_finish, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> size_type len = old_size + std::<span class="built_in">max</span>(old_size, n);</span><br><span class="line">    iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    iterator new_finish = start;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_fill_n</span>(new_finish, n, x);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.31 更新：增加了更多的构造函数，支持“窃取”内存操作。</p>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 3-2：链表 list</title>
    <url>/2024/08/31/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%973-2/</url>
    <content><![CDATA[<p>每个 C 语言学习者应该都学过链表，至少自己尝试过链表。list 是相比
vector 更加灵活的数据结构，支持绝对精准地使用内存空间，通过私有方法
transfer() 提供了 merge(), sort(), unique(), splice(), reverse()
等方法，弥补 list 没有 random access iterator 的缺陷。</p>
<p>笔者学链表看的是浙江大学翁恺老师的课程，以为自己学会了，但 C++
双向链表还是有不少难处。这次相比标准库优化的是，只要用户获取了迭代器，同样可以把这个
list
作为环状链表访问，也就可以模拟约瑟夫问题（之类的）。这次还提供了更多的内存操作，支持复制构造/右值引用构造/迭代器区间构造/重载赋值运算符/
swap 窃取等，请看具体实现。</p>
<span id="more"></span>
<h4 id="实现">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_alloc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_iterator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> node_pointer = __list_node&lt;T&gt;*;</span><br><span class="line">    node_pointer prev;</span><br><span class="line">    node_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ref, <span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> iterator = __list_iterator&lt;T, T&amp;, T*&gt;;</span><br><span class="line">    <span class="keyword">using</span> self = __list_iterator&lt;T, Ref, Ptr&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> iterator_category = bidirection_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> pointer = Ptr;</span><br><span class="line">    <span class="keyword">using</span> reference = Ref;</span><br><span class="line">    <span class="keyword">using</span> link_type = __list_node&lt;T&gt;*;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">    link_type node;</span><br><span class="line"></span><br><span class="line">    __list_iterator() &#123; &#125;</span><br><span class="line">    __list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123; &#125;</span><br><span class="line">    __list_iterator(<span class="type">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> node-&gt;data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;<span class="keyword">operator</span>*(); &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        node = node-&gt;prev;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        node = node-&gt;prev;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> list</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> list_node = __list_node&lt;T&gt;;</span><br><span class="line">    <span class="keyword">using</span> list_node_allocator = simple_alloc&lt;list_node, Alloc&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">    <span class="keyword">using</span> iterator = __list_iterator&lt;T, T&amp;, T*&gt;;</span><br><span class="line">    <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> link_type = list_node*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">    <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list_node_allocator::<span class="built_in">allocate</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; list_node_allocator::<span class="built_in">deallocate</span>(p); &#125;</span><br><span class="line">    <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        link_type p = <span class="built_in">get_node</span>();</span><br><span class="line">        <span class="built_in">construct</span> (&amp;p-&gt;data, x);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(&amp;p-&gt;data);</span><br><span class="line">        <span class="built_in">put_node</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">empty_initialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        node = <span class="built_in">get_node</span>();</span><br><span class="line">        node-&gt;next = node;</span><br><span class="line">        node-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position == last) <span class="keyword">return</span>;</span><br><span class="line">        last.node-&gt;prev-&gt;next = position.node;</span><br><span class="line">        first.node-&gt;prev-&gt;next = last.node;</span><br><span class="line">        position.node-&gt;prev-&gt;next = first.node;</span><br><span class="line">        link_type tmp = position.node-&gt;prev;</span><br><span class="line">        position.node-&gt;prev = last.node-&gt;prev;</span><br><span class="line">        last.node-&gt;prev = first.node-&gt;prev;</span><br><span class="line">        first.node-&gt;prev = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node-&gt;next; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node-&gt;next == node; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        size_type result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--<span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>() &#123; <span class="built_in">empty_initialized</span>(); &#125;</span><br><span class="line">    ~<span class="built_in">list</span>() &#123; <span class="built_in">clear</span>(), <span class="built_in">destroy_node</span>(node); &#125;</span><br><span class="line">    <span class="built_in">list</span>(list&amp;);</span><br><span class="line">    <span class="built_in">list</span>(list&amp;&amp;);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">    <span class="built_in">list</span>(InputIterator first, InputIterator last);</span><br><span class="line">    list&amp; <span class="keyword">operator</span>=(list&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp;)</span> </span>&#123;</span><br><span class="line">        link_type tmp = <span class="built_in">create_node</span>(x);</span><br><span class="line">        tmp-&gt;next = position.node;</span><br><span class="line">        tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">        position.node-&gt;prev-&gt;next = tmp;</span><br><span class="line">        position.node-&gt;prev = tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">begin</span>(), x); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">end</span>(), x); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">        link_type next_node = position.node-&gt;next;</span><br><span class="line">        link_type prev_node = position.node-&gt;prev;</span><br><span class="line">        prev_node-&gt;next = next_node;</span><br><span class="line">        next_node-&gt;prev = prev_node;</span><br><span class="line">        <span class="built_in">destroy_node</span>(position.node);</span><br><span class="line">        <span class="keyword">return</span> next_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; <span class="built_in">erase</span>(--<span class="built_in">end</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(list&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator i)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator first, iterator last)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">list&lt;T, Alloc&gt;::<span class="built_in">list</span>(list&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">empty_initialized</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> T&amp; item : x)</span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">list&lt;T, Alloc&gt;::<span class="built_in">list</span>(list&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">empty_initialized</span>();</span><br><span class="line">    <span class="built_in">swap</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line">list&lt;T, Alloc&gt;::<span class="built_in">list</span>(InputIterator first, InputIterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">empty_initialized</span>();</span><br><span class="line">    <span class="keyword">for</span> (; first != last; first++)</span><br><span class="line">        <span class="built_in">push_back</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">list&lt;T, Alloc&gt;&amp; list&lt;T, Alloc&gt;::<span class="keyword">operator</span>=(list&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> T&amp; item : x)</span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">swap</span>(list&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(node, x.node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    link_type cur = node-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur != node) &#123;</span><br><span class="line">        link_type tmp = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="built_in">destroy_node</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next = node;</span><br><span class="line">    node-&gt;prev = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">remove</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        iterator next = first;</span><br><span class="line">        next++;</span><br><span class="line">        <span class="keyword">if</span> (*first == value)</span><br><span class="line">            <span class="built_in">erase</span>(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">unique</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    iterator first = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last = <span class="built_in">end</span>();</span><br><span class="line">    iterator next = first;</span><br><span class="line">    <span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first == *next)</span><br><span class="line">            <span class="built_in">erase</span>(next);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            first = next;</span><br><span class="line">        next = first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">splice</span>(iterator position, list&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">transfer</span>(position, x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">splice</span>(iterator position, list&amp;, iterator i)</span><br><span class="line">&#123;</span><br><span class="line">    iterator j = i;</span><br><span class="line">    j++;</span><br><span class="line">    <span class="keyword">if</span> (position == i <span class="keyword">or</span> position == j)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">transfer</span>(position, i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">splice</span>(iterator position, list&amp;, iterator first, iterator last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">transfer</span>(position, first, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">merge</span>(list&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    iterator first1 = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last1 = <span class="built_in">end</span>();</span><br><span class="line">    iterator first2 = x.<span class="built_in">begin</span>();</span><br><span class="line">    iterator last2 = x.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 <span class="keyword">and</span> first2 != last2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*first1 &lt;= *first2) &#123;</span><br><span class="line">            first1++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator next = first2;</span><br><span class="line">        <span class="built_in">transfer</span>(first1, first2, ++next);</span><br><span class="line">        first2 = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first2 != last2)</span><br><span class="line">        <span class="built_in">transfer</span>(last1, first2, last2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">reverse</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node-&gt;prev) <span class="keyword">return</span>;</span><br><span class="line">    iterator first = ++<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="built_in">end</span>()) &#123;</span><br><span class="line">        iterator old = first;</span><br><span class="line">        ++first;</span><br><span class="line">        <span class="built_in">transfer</span>(<span class="built_in">begin</span>(), old, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T, Alloc&gt;::<span class="built_in">sort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node-&gt;prev) <span class="keyword">return</span>;</span><br><span class="line">    list&lt;T, Alloc&gt; carry;</span><br><span class="line">    list&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; fill; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter[i].<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            counter[i].<span class="built_in">merge</span>(carry);</span><br><span class="line">            carry.<span class="built_in">swap</span>(counter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        carry.<span class="built_in">swap</span>(counter[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == fill) fill++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; fill; i++)</span><br><span class="line">        counter[i].<span class="built_in">merge</span>(counter[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">swap</span>(counter[fill - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 3-3：双头队列 deque</title>
    <url>/2024/09/02/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%973-3/</url>
    <content><![CDATA[<p>deque
是双向开口的连续线性空间，一款支持头尾操作、随机访问的几乎完美的序列式容器。通过一个中控器
map（不是那个红黑树），在分段的连续空间上维护其整体连续的假象，设计数据结构、迭代器增减操作都颇为繁琐。</p>
<p>开发 deque 的过程中，C++
标准库的设计哲学发挥了指导性的作用。由于其操作本身很复杂，不可避免地会设计出大量复杂的抽象层级。但是，还需要为用户提供傻瓜式的接口，最大可能隐藏实现细节。</p>
<p>难度虽高，但借助 STL
高质量的源码，最复杂的部分解决后，我们自己也可以使用那些傻瓜式接口。例如
insert() 与 erase() 实现起来比我想象中更简单，因为最复杂的部分已经隐藏在
iterator 的设计中了，接下来只需要 copy 或 copy_backward
就可以。（注：一想到不用一个个操作中控器，心情舒畅了不少，开发效率都提高了）</p>
<p>此外笔者一直纠结于 const 语法和语义的冲突，今天突然悟到了
const_iterator 是怎么实现的，马上会再去修改前面的 vector 和 list。至于
reverse_iterator，就和 adapter 一起开发吧，鸽了。</p>
<span id="more"></span>
<h4 id="实现">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_alloc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_construct.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_uninitialized.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_iterator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iso646.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">512</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span> (sz &gt;= <span class="number">512</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">512</span> / sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ref, <span class="keyword">typename</span> Ptr, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> iterator = __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*, BufSize&gt;;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> pointer = Ptr;</span><br><span class="line">    <span class="keyword">using</span> reference = Ref;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> map_pointer = T**;</span><br><span class="line">    <span class="keyword">using</span> self = __deque_iterator;</span><br><span class="line"></span><br><span class="line">    T* cur;</span><br><span class="line">    T* first;</span><br><span class="line">    T* last;</span><br><span class="line">    map_pointer node;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">        node = new_node;</span><br><span class="line">        first = *new_node;</span><br><span class="line">        last = first + <span class="built_in">buffer_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(*cur); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == x.node) <span class="keyword">return</span> cur &lt; x.cur;</span><br><span class="line">        <span class="keyword">return</span> node &lt; x.node;</span><br><span class="line">    &#125;</span><br><span class="line">    difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buffer_size</span>() * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        cur++;</span><br><span class="line">        <span class="keyword">if</span> (cur == last) &#123;</span><br><span class="line">            <span class="built_in">set_node</span>(node + <span class="number">1</span>);</span><br><span class="line">            cur = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == first) &#123;</span><br><span class="line">            <span class="built_in">set_node</span>(node - <span class="number">1</span>);</span><br><span class="line">            cur = last;</span><br><span class="line">        &#125;</span><br><span class="line">        --cur;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">        difference_type offset = n + (cur - first);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> <span class="keyword">and</span> offset &lt; <span class="built_in">buffer_size</span>())</span><br><span class="line">            cur += n;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            difference_type node_offset = offset / <span class="built_in">buffer_size</span>();</span><br><span class="line">            <span class="keyword">if</span> (offset &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                node_offset = (-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>();</span><br><span class="line">                node_offset = -node_offset - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">            cur = first + (offset - node_offset * <span class="built_in">buffer_size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp += n;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> += n;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp -= n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *(*<span class="keyword">this</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = alloc, <span class="type">size_t</span> BufSiz = <span class="number">512</span>&gt;</span><br><span class="line"><span class="keyword">class</span> deque</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">    <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> iterator = __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="type">const</span> value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*, BufSiz&gt;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> data_allocator = simple_alloc&lt;value_type, Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> map_allocator = simple_alloc&lt;pointer, Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> map_pointer = pointer*;</span><br><span class="line">    map_pointer map;</span><br><span class="line">    size_type map_size;</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">initial_map_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create_map_and_nodes</span><span class="params">(size_type num_elements)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">realloate_map</span><span class="params">(size_type nodes_to_add, <span class="type">bool</span> add_at_front)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealloate_map</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse_map_at_front</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse_map_at_back</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type, <span class="type">const</span> value_type&amp;)</span></span>;</span><br><span class="line">    <span class="function">pointer <span class="title">allocate_node</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dealloate_node</span><span class="params">(pointer)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front_aux</span><span class="params">(<span class="type">const</span> value_type&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back_aux</span><span class="params">(<span class="type">const</span> value_type&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front_aux</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back_aux</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">insert_aux</span><span class="params">(iterator, <span class="type">const</span> value_type&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> start[n]; &#125;    </span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> *tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    const_reference <span class="keyword">operator</span>[](size_type n) <span class="type">const</span> &#123; <span class="keyword">return</span> start[n]; &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> *tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">deque</span>() : <span class="built_in">map</span>(<span class="literal">nullptr</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">create_map_and_nodes</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>(<span class="type">int</span> n, <span class="type">const</span> T&amp; value) : <span class="built_in">map</span>(<span class="literal">nullptr</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>(<span class="type">const</span> deque&amp; q) : <span class="built_in">map</span>(<span class="literal">nullptr</span>), <span class="built_in">map_size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">create_map_and_nodes</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> T&amp; x : q)</span><br><span class="line">            <span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>(deque&amp;&amp; q) &#123;</span><br><span class="line">        map = q.map;</span><br><span class="line">        map_size = q.size;</span><br><span class="line">        q.map = <span class="literal">nullptr</span>;</span><br><span class="line">        q.map_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">deque</span>() &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">deallocate_map</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(deque&amp; q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(map, q.map);</span><br><span class="line">        <span class="built_in">swap</span>(map_size, q.map_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">auto</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">allocate_node</span>() -&gt; pointer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> data_allocator::<span class="built_in">allocate</span>(BufSiz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">dealloate_node</span>(pointer p)</span><br><span class="line">&#123;</span><br><span class="line">    data_allocator::<span class="built_in">deallocate</span>(p, BufSiz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements)</span><br><span class="line">&#123;</span><br><span class="line">    size_type num_nodes = num_elements / iterator::<span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line">    map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">    map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line"></span><br><span class="line">    map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">    map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (map_pointer cur = nstart; cur &lt;= nfinish; cur++)</span><br><span class="line">            *cur = <span class="built_in">allocate_node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (map_pointer cur = nstart; cur &lt;= nfinish; cur++)</span><br><span class="line">            <span class="built_in">deallocate_node</span>(*cur);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">    finish.cur = finish.first + num_elements % <span class="built_in">buffer_size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">realloate_map</span>(size_type nodes_to_add, <span class="type">bool</span> add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">    size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">    size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line">    map_pointer new_nstart;</span><br><span class="line">    <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes)</span><br><span class="line">    &#123;</span><br><span class="line">        new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (add_at_front) new_nstart += nodes_to_add;</span><br><span class="line">        <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">            std::<span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::<span class="built_in">copy_backward</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size_type new_map_size = map_size + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">        map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size);</span><br><span class="line">        new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (add_at_front) new_nstart += nodes_to_add;</span><br><span class="line">        </span><br><span class="line">        std::<span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">        map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">        map = new_map;</span><br><span class="line">        map_size = new_map_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">dealloate_map</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">reverse_map_at_front</span>(size_type nodes_to_add)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt;= map_size - (finish.node - map))</span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">reverse_map_at_back</span>(size_type nodes_to_add)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - map)</span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">fill_initialize</span>(size_type n, <span class="type">const</span> value_type&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(n);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; finish.node; cur++)</span><br><span class="line">            <span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value);</span><br><span class="line">        <span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; finish.node; cur++)</span><br><span class="line">            <span class="built_in">destroy</span>(*cur, *cur + <span class="built_in">buffer_size</span>());</span><br><span class="line">        <span class="built_in">destroy</span>(finish.first, finish.cur);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type&amp;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">reverse_map_at_back</span>();</span><br><span class="line">    map_pointer new_node = finish.node + <span class="number">1</span>;</span><br><span class="line">    *new_node = <span class="built_in">allocate_node</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, value);</span><br><span class="line">        finsh.<span class="built_in">set_node</span>(new_node);</span><br><span class="line">        finish.cur = finish.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">deallocate_node</span>(*new_node);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur + <span class="number">1</span> != finish.last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, value);</span><br><span class="line">        finish.cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">push_back_aux</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">push_front_aux</span>(<span class="type">const</span> value_type&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">reverse_map_at_front</span>();</span><br><span class="line">    map_pointer new_node = start.node - <span class="number">1</span>;</span><br><span class="line">    *new_node = <span class="built_in">allocate_node</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start.<span class="built_in">set_node</span>(new_node);</span><br><span class="line">        start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">construct</span>(start.cur, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);</span><br><span class="line">        start.cur = start.first;</span><br><span class="line">        <span class="built_in">deallocate_node</span>(new_node);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">push_front</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, value);</span><br><span class="line">        start.cur--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">push_front_aux</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">pop_back_aux</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">deallocate_node</span>(finish.first);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);</span><br><span class="line">    finsh.cur = finish.last - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">destroy</span>(finish.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first)</span><br><span class="line">    &#123;</span><br><span class="line">        finish.cur--;</span><br><span class="line">        <span class="built_in">destroy</span>(finish.cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">pop_back_aux</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">pop_front_aux</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(start.cur);</span><br><span class="line">    <span class="built_in">deallocate_node</span>(start.first);</span><br><span class="line">    start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">pop_front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(start.cur);</span><br><span class="line">        start.cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">pop_front_aux</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; node++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>());</span><br><span class="line">        data::allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start.node != finish.node) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, start.last);</span><br><span class="line">        <span class="built_in">destroy</span>(finish.first, finish.cur);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, finish.cur);</span><br><span class="line">    </span><br><span class="line">    finish = start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">auto</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">erase</span>(iterator pos) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    next++;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">copy_backward</span>(start, pos, next);</span><br><span class="line">        <span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">copy</span>(next, finish, pos);</span><br><span class="line">        <span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">auto</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">erase</span>(iterator first, iterator last) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == start <span class="keyword">and</span> last == finish) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    difference_type n = last - first;</span><br><span class="line">    difference_type elems_before = first - start;</span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">copy_backward</span>(start, first, last);</span><br><span class="line">        iterator new_start = start + n;</span><br><span class="line">        <span class="built_in">destroy</span>(start, new_start);</span><br><span class="line">        <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; cur++)</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">        start = new_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">        iterator new_finish = finish - n;</span><br><span class="line">        <span class="built_in">destroy</span>(new_finish, finish);</span><br><span class="line">        <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; cur++)</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">        finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + elems_before;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">auto</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">insert</span>(iterator position, <span class="type">const</span> T&amp; value) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">        <span class="built_in">push_front</span>(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        tmp--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">auto</span> deque&lt;T, Alloc, BufSiz&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> T&amp; value) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">        iterator front1 = start;</span><br><span class="line">        front1++;</span><br><span class="line">        iterator front2 = front1;</span><br><span class="line">        front2++;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        iterator pos1 = pos;</span><br><span class="line">        pos1++;</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">        iterator back1 = finish;</span><br><span class="line">        back1--;</span><br><span class="line">        iterator back2 = back1;</span><br><span class="line">        back2--;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 3-4：栈 stack &amp; 队列 queue</title>
    <url>/2024/09/03/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%973-4/</url>
    <content><![CDATA[<p>比起前两天的工作，这次的难度可以忽略不计了，那就是开发 stack 和
queue。事实上，stack 和 queue 不能称之为 container，只能称之为 container
adapter。以既有容器（list 或
deque）为底层，对其接口进行一点简单的包装，就能轻而易举地实现“先进先出”或“先进后出”的特性。</p>
<p>这么简单也要水一篇文章，就是对我们辛苦付出的补偿（：</p>
<span id="more"></span>
<h4 id="实现">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_stack.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_deque.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Sequence = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// friend bool operator==(const stack&amp;, const stack&amp;);</span></span><br><span class="line">    <span class="comment">// friend bool operator&lt; (const stack&amp;, const stack&amp;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = Sequence::value_type;</span><br><span class="line">    <span class="keyword">using</span> size_type = Sequence::size_type;</span><br><span class="line">    <span class="keyword">using</span> refrence = Sequence::reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = Sequence::const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_queue.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_deque.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Sequence = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// friend bool operator==(const queue&amp; x, const queue&amp; y);</span></span><br><span class="line">    <span class="comment">// friend bool operator&lt; (const queue&amp; x, const queue&amp; y);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = Sequence::value_type;</span><br><span class="line">    <span class="keyword">using</span> size_type = Sequence::size_type;</span><br><span class="line">    <span class="keyword">using</span> reference = Sequence::reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = Sequence::const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 3-5：优先队列 priority_queue</title>
    <url>/2024/09/03/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%973-5/</url>
    <content><![CDATA[<p>严格来说，priority_queue 也不能算是一个 container，它是以 vector
为基础、辅以 heap 系列算法的
adapter。在这种狭窄的应用场景下，堆是比红黑树更有性价比的选择，因为红黑树的常数太大了。</p>
<p>话不多说，后面是 heap 系列算法的实现，包括
push_heap()、pop_heap()、sort_heap()、make_heap() 等，其中 sort_heap()
指堆排序，也是一个优秀的排序算法。然后是简洁优美的
priority_queue，支持自定义 Compare 类，默认为大根堆。</p>
<span id="more"></span>
<h4 id="实现">实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_heap.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_iterator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iso646.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function push_heap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Distance, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value)</span><br><span class="line">&#123;</span><br><span class="line">    Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (holeIndex &gt; topIndex <span class="keyword">and</span> first[parent] &lt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        first[holeIndex] = first[parent];</span><br><span class="line">        holeIndex = parent;</span><br><span class="line">        parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    first[holeIndex] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Distance, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*)</span><br><span class="line">&#123;</span><br><span class="line">    __push_heap(first, <span class="built_in">Distance</span>(last - first - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Distance, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __push_heap(RandomAccessIterator first, <span class="type">const</span> Compare&amp; comp, Distance holeIndex, Distance topIndex, T value)</span><br><span class="line">&#123;</span><br><span class="line">    Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (holeIndex &gt; topIndex <span class="keyword">and</span> <span class="built_in">comp</span>(first[parent], value))</span><br><span class="line">    &#123;</span><br><span class="line">        first[holeIndex] = first[parent];</span><br><span class="line">        holeIndex = parent;</span><br><span class="line">        parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    first[holeIndex] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Distance, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> Compare&amp; comp, Distance*, T*)</span><br><span class="line">&#123;</span><br><span class="line">    __push_heap(first, comp, <span class="built_in">Distance</span>(last - first - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> Compare&amp; comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __push_heap_aux(first, last, comp, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function pop_heap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Distance, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value)</span><br><span class="line">&#123;</span><br><span class="line">    Distance topIndex = holeIndex;</span><br><span class="line">    Distance secondChild = holeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (secondChild &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (first[secondChild] &lt; first[secondChild - <span class="number">1</span>])</span><br><span class="line">            secondChild--;</span><br><span class="line">        first[holeIndex] = first[secondChild];</span><br><span class="line">        holeIndex = secondChild;</span><br><span class="line">        secondChild = holeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secondChild == len)</span><br><span class="line">    &#123;</span><br><span class="line">        first[holeIndex] = first[secondChild - <span class="number">1</span>];</span><br><span class="line">        holeIndex = secondChild - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __push_heap(first, holeIndex, topIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Distance, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __adjust_heap(RandomAccessIterator first, <span class="type">const</span> Compare&amp; comp, Distance holeIndex, Distance len, T value)</span><br><span class="line">&#123;</span><br><span class="line">    Distance topIndex = holeIndex;</span><br><span class="line">    Distance secondChild = holeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (secondChild &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">comp</span>(first[secondChild], first[secondChild - <span class="number">1</span>]))</span><br><span class="line">            secondChild--;</span><br><span class="line">        first[holeIndex] = first[secondChild];</span><br><span class="line">        holeIndex = secondChild;</span><br><span class="line">        secondChild = holeIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secondChild == len)</span><br><span class="line">    &#123;</span><br><span class="line">        first[holeIndex] = first[secondChild - <span class="number">1</span>];</span><br><span class="line">        holeIndex = secondChild - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __push_heap(first, comp, holeIndex, topIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last, </span><br><span class="line">                RandomAccessIterator result, T value, Distance*)</span><br><span class="line">&#123;</span><br><span class="line">    *result = *first;</span><br><span class="line">    __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*)</span><br><span class="line">&#123;</span><br><span class="line">    __pop_heap(first, last - <span class="number">1</span>, last - <span class="number">1</span>, <span class="built_in">T</span>(*(last - <span class="number">1</span>)), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> __pop_heap(RandomAccessIterator first, RandomAccessIterator last, </span><br><span class="line">                RandomAccessIterator result, <span class="type">const</span> Compare&amp; comp, T value, Distance*)</span><br><span class="line">&#123;</span><br><span class="line">    *result = *first;</span><br><span class="line">    __adjust_heap(first, comp, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> Compare&amp; comp, T*)</span><br><span class="line">&#123;</span><br><span class="line">    __pop_heap(first, last - <span class="number">1</span>, last - <span class="number">1</span>, comp, <span class="built_in">T</span>(*(last - <span class="number">1</span>)), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> Compare&amp; comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, comp, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function sort_heap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">pop_heap</span>(first, last--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> Compare&amp; comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">pop_heap</span>(first, last--, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function make_heap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*, Distance*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    Distance parent = (len - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        __adjust_heap(first, parent, len, first[parent]);</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        parent--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="type">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> Compare&amp; comp, T*, Distance*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    Distance parent = (len - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        __adjust_heap(first, comp, parent, len, first[parent]);</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        parent--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, <span class="type">const</span> Compare&amp; comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __make_heap(first, last, comp, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_priority_queue.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waiting for less&lt;T&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Sequence = vector&lt;T&gt;,</span><br><span class="line">          <span class="keyword">typename</span> Compare = std::less&lt;<span class="keyword">typename</span> Sequence::value_type&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Sequence::value_type;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Sequence::size_type;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">typename</span> Sequence::reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Sequence::const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line">    Compare comp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">priority_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="type">const</span> Compare&amp; x)</span> : comp(x) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.<span class="built_in">push_back</span>(x);</span><br><span class="line">            Tiny::<span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            c.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Tiny::<span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">            c.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            c.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 3-X：序列式容器的测试</title>
    <url>/2024/09/03/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%973-X/</url>
    <content><![CDATA[<p>结束序列式容器的开发，进入关联式容器之前，磨刀不误砍柴工，分享一下简单测试每个容器的程序。</p>
<span id="more"></span>
<h4 id="一动态数组-vector">一、动态数组 vector</h4>
<p>注：为了检验 const_iterator 与 const_reference
的有效性，写了两个函数测试传递后的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_vector.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_vector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tiny;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; a.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;capacity = &quot;</span> &lt;&lt; a.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="built_in">display</span>(a), <span class="built_in">show</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">display</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">show</span>(a);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">display</span>(a), <span class="built_in">show</span>(a);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">display</span>(a), <span class="built_in">show</span>(a);</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">display</span>(a);</span><br><span class="line">    </span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">display</span>(a), <span class="built_in">show</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二链表-list">二、链表 list</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_list.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tiny;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; ilist;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; ilist.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ilist.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    ilist.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    ilist.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    ilist.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line">    ilist.<span class="built_in">push_front</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; ilist.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ilist.<span class="built_in">begin</span>(); it != ilist.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="三双向队列-deque">三、双向队列 deque</h4>
<p>双向队列测试完了，栈和队列也就测试完了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_deque.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_deque.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tiny;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">deque&lt;<span class="type">int</span>, alloc, 32&gt; <span class="title">ideq</span><span class="params">(<span class="number">20</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); i++)</span><br><span class="line">        ideq[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ideq.<span class="built_in">push_front</span>(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    ideq.<span class="built_in">push_front</span>(<span class="number">98</span>);</span><br><span class="line">    ideq.<span class="built_in">push_front</span>(<span class="number">97</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ideq.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; ideq[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; ideq.<span class="built_in">size</span>() &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="四heap-系列算法与优先队列-priority_queue">四、heap
系列算法与优先队列 priority_queue</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_heap.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tiny;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">9</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        a[i] = ia[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">push_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pop_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_priority_queue.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_priority_queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tiny;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">9</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : ia) q.<span class="built_in">push</span>(x);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 4-1：红黑树 rb-tree</title>
    <url>/2024/09/06/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%974-1/</url>
    <content><![CDATA[<p>真正的重头戏来了！平衡二叉搜索树中最常用的红黑树 RB-Tree，不仅能在
O(logn)
以内完成查询、插入、删除操作，还具有非常优秀的常数，高频修改的效率远非
AVL 树可比。</p>
<p>为了实现 set 与 map，笔者仿造《STL源码剖析》中的 std::rb_tree 实现了
insert, clear, find 等操作，同时补充了 erase, lower_bound, upper_bound,
以及复制构造函数、重载复制运算符等内存操作。</p>
<p>本次还补充了更多的 const 方法，学习 SGI STL
的非侵入式容器方法，是最接近库函数源代码的一次，还设计了更复杂的测试程序，覆盖了各种不同的插入/删除场景，附于文章末尾。以下是源代码。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_tree.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waiting for pair&lt;&gt;, swap()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_construct.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_alloc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_iterator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iso646.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> __rb_tree_color_type = <span class="type">bool</span>;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node_base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> color_type = __rb_tree_color_type;</span><br><span class="line">    <span class="keyword">using</span> base_ptr = __rb_tree_node_base*;</span><br><span class="line"></span><br><span class="line">    color_type color;</span><br><span class="line">    base_ptr parent;</span><br><span class="line">    base_ptr left;</span><br><span class="line">    base_ptr right;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_node</span> : <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> link_type = __rb_tree_node&lt;Value&gt;*;</span><br><span class="line">    Value value_field;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> base_ptr = __rb_tree_node_base::base_ptr;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = bidirectional_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">    base_ptr node;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            base_ptr y = node-&gt;parent;</span><br><span class="line">            <span class="keyword">while</span> (node == y-&gt;right)</span><br><span class="line">                node = y, y = y-&gt;parent;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != y)</span><br><span class="line">                node = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;color == __rb_tree_red <span class="keyword">and</span></span><br><span class="line">            node-&gt;parent-&gt;parent == node)</span><br><span class="line">        &#123;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            base_ptr y = node-&gt;left;</span><br><span class="line">            <span class="keyword">while</span> (y-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                y = y-&gt;right;</span><br><span class="line">            node = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            base_ptr y = node-&gt;parent;</span><br><span class="line">            <span class="keyword">while</span> (node == y-&gt;left)</span><br><span class="line">                node = y, y = y-&gt;parent;</span><br><span class="line">            node = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Ref, <span class="keyword">typename</span> Ptr&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rb_tree_iterator</span> : <span class="keyword">public</span> __rb_tree_base_iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = Value;</span><br><span class="line">    <span class="keyword">using</span> reference = Ref;</span><br><span class="line">    <span class="keyword">using</span> pointer = Ptr;</span><br><span class="line">    <span class="keyword">using</span> iterator = __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = __rb_tree_iterator&lt;Value, <span class="type">const</span> Value&amp;, <span class="type">const</span> Value*&gt;;</span><br><span class="line">    <span class="keyword">using</span> self = __rb_tree_iterator&lt;Value, Ref, Ptr&gt;;</span><br><span class="line">    <span class="keyword">using</span> link_type = __rb_tree_node&lt;Value&gt;*;</span><br><span class="line"></span><br><span class="line">    __rb_tree_iterator() = <span class="keyword">default</span>;</span><br><span class="line">    __rb_tree_iterator(link_type x) &#123; node = x; &#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> __rb_tree_iterator&amp; x) <span class="type">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> __rb_tree_iterator&amp; x) <span class="type">const</span></span><br><span class="line">        &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123; </span><br><span class="line">        <span class="built_in">increment</span>(); </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">increment</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="built_in">decrement</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">decrement</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> rb_tree</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> void_pointer = <span class="type">void</span>*;</span><br><span class="line">    <span class="keyword">using</span> base_ptr = __rb_tree_node_base*;</span><br><span class="line">    <span class="keyword">using</span> rb_tree_node = __rb_tree_node&lt;Value&gt;;</span><br><span class="line">    <span class="keyword">using</span> rb_tree_node_allocator = simple_alloc&lt;rb_tree_node, Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> color_type = __rb_tree_color_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> value_type = Value;</span><br><span class="line">    <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">    <span class="keyword">using</span> const_pointer = <span class="type">const</span> value_type*;</span><br><span class="line">    <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="type">const</span> value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> link_type = rb_tree_node*;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> self = rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">allocate</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; <span class="keyword">return</span> rb_tree_node_allocator::<span class="built_in">deallocate</span>(p); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        link_type tmp = <span class="built_in">get_node</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">construct</span>(&amp;tmp-&gt;value_field, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="built_in">put_node</span>(tmp);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">link_type <span class="title">clone_node</span><span class="params">(link_type x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        link_type tmp = <span class="built_in">create_node</span>(x-&gt;value_field);</span><br><span class="line">        tmp-&gt;color = x-&gt;color;</span><br><span class="line">        tmp-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        tmp-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(&amp;p-&gt;value_field);</span><br><span class="line">        <span class="built_in">put_node</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    size_type node_count;</span><br><span class="line">    link_type header;</span><br><span class="line">    Compare key_compare;</span><br><span class="line"></span><br><span class="line">    <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;parent; &#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;left; &#125;</span><br><span class="line">    <span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)header-&gt;right; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)x-&gt;left; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)x-&gt;right; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)x-&gt;parent; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;color; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)x-&gt;left; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)x-&gt;right; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)x-&gt;parent; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">link_type</span>(x)-&gt;value_field; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(<span class="built_in">link_type</span>(x))); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">link_type</span>(x)-&gt;color; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type)__rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (link_type)__rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __rb_tree_rotate_left(base_ptr, base_ptr&amp; root);</span><br><span class="line">    <span class="type">void</span> __rb_tree_rotate_right(base_ptr, base_ptr&amp; root);</span><br><span class="line">    <span class="type">void</span> __rb_tree_rebalance_insert(base_ptr, base_ptr&amp; root);</span><br><span class="line">    base_ptr __rb_tree_rebalance_erase(base_ptr, base_ptr&amp; root);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator = __rb_tree_iterator&lt;value_type, reference, pointer&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = __rb_tree_iterator&lt;value_type, const_reference, const_pointer&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator __insert(base_ptr x, base_ptr y, <span class="type">const</span> value_type&amp; v);</span><br><span class="line">    link_type __copy(link_type x, link_type p);</span><br><span class="line">    <span class="type">void</span> __erase(link_type x);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        header = <span class="built_in">get_node</span>();</span><br><span class="line">        <span class="built_in">color</span>(header) = __rb_tree_red;</span><br><span class="line">        <span class="built_in">root</span>() = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">leftmost</span>() = header;</span><br><span class="line">        <span class="built_in">rightmost</span>() = header;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">rb_tree</span>(<span class="type">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">        : <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line">    <span class="built_in">rb_tree</span>(<span class="type">const</span> self&amp;);</span><br><span class="line">    <span class="built_in">rb_tree</span>(self&amp;&amp;);</span><br><span class="line">    ~<span class="built_in">rb_tree</span>() &#123; <span class="built_in">clear</span>(), <span class="built_in">put_node</span>(header); &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>=(<span class="type">const</span> self&amp; x);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(self&amp; x)</span></span>;</span><br><span class="line">    <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> size_type <span class="title">max_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp;)</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> Key&amp;)</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> Key&amp;)</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> Key&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> Key&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp;)</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> Key&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__copy(link_type x, link_type p) -&gt; link_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    link_type top = <span class="built_in">clone_node</span>(x);</span><br><span class="line">    top-&gt;parent = p;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        top-&gt;right = __copy(x-&gt;right);</span><br><span class="line">        top-&gt;left = __copy(x-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        __erase(top);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">rb_tree</span>(<span class="type">const</span> self&amp; x)</span><br><span class="line">    : <span class="built_in">node_count</span>(x.node_count), <span class="built_in">key_comp</span>(x.key_comp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">root</span>() = __copy(x.<span class="built_in">root</span>(), header);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">put_node</span>(<span class="built_in">root</span>());</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">leftmost</span>() = <span class="built_in">minimum</span>(<span class="built_in">root</span>());</span><br><span class="line">    <span class="built_in">rightmost</span>() = <span class="built_in">maximum</span>(<span class="built_in">root</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">rb_tree</span>(self&amp;&amp; x)</span><br><span class="line">    : <span class="built_in">node_count</span>(x.node_count), <span class="built_in">header</span>(x.header), <span class="built_in">key_compare</span>(x.key_compare)</span><br><span class="line">&#123;</span><br><span class="line">    x.header = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> self&amp; x) -&gt; self&amp;</span><br><span class="line">&#123;</span><br><span class="line">    node_count = x.node_count;</span><br><span class="line">    key_compare = x.key_compare;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">root</span>() = __copy(x.<span class="built_in">root</span>(), header);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">put_node</span>(<span class="built_in">root</span>());</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">leftmost</span>() = <span class="built_in">minimum</span>(<span class="built_in">root</span>());</span><br><span class="line">    <span class="built_in">rightmost</span>() = <span class="built_in">maximum</span>(<span class="built_in">root</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">swap</span>(self&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(node_count, x.node_count);</span><br><span class="line">    <span class="built_in">swap</span>(header, x.header);</span><br><span class="line">    <span class="built_in">swap</span>(key_compare, x.key_compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="type">const</span> value_type&amp; v) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>();</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="type">const</span> value_type&amp; v) -&gt; std::pair&lt;iterator, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>();</span><br><span class="line">    <span class="type">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x));</span><br><span class="line">        x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (comp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">begin</span>())</span><br><span class="line">            <span class="keyword">return</span> &#123; __insert(x, y, v), <span class="literal">true</span> &#125;;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">        <span class="keyword">return</span> &#123; __insert(x, y, v), <span class="literal">true</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123; j, <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__insert(base_ptr x_, base_ptr y_, <span class="type">const</span> Value&amp; v) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    link_type x = (link_type)x_;</span><br><span class="line">    link_type y = (link_type)y_;</span><br><span class="line">    link_type z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y == header <span class="keyword">or</span> x != <span class="literal">nullptr</span> <span class="keyword">or</span> <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(y)))</span><br><span class="line">    &#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v);</span><br><span class="line">        <span class="built_in">left</span>(y) = z;</span><br><span class="line">        <span class="keyword">if</span> (y == header) &#123;</span><br><span class="line">            <span class="built_in">root</span>() = z;</span><br><span class="line">            <span class="built_in">rightmost</span>() = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">leftmost</span>())</span><br><span class="line">            <span class="built_in">leftmost</span>() = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        z = <span class="built_in">create_node</span>(v);</span><br><span class="line">        <span class="built_in">right</span>(y) = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">parent</span>(z) = y;</span><br><span class="line">    <span class="built_in">left</span>(z) = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">right</span>(z) = <span class="literal">nullptr</span>;</span><br><span class="line">    __rb_tree_rebalance_insert(z, header-&gt;parent);</span><br><span class="line">    node_count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__rb_tree_rebalance_insert(base_ptr x, base_ptr&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">    x-&gt;color = __rb_tree_red;</span><br><span class="line">    <span class="keyword">while</span> (x != root <span class="keyword">and</span> x-&gt;parent-&gt;color == __rb_tree_red)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            base_ptr y = x-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (y <span class="keyword">and</span> y-&gt;color == __rb_tree_red) &#123;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">                y-&gt;color = __rb_tree_black;</span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                x = x-&gt;parent-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;right) &#123;</span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    __rb_tree_rotate_left(x, root);</span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                __rb_tree_rotate_right(x-&gt;parent-&gt;parent, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            base_ptr y = x-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (y <span class="keyword">and</span> y-&gt;color == __rb_tree_red) &#123;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">                y-&gt;color = __rb_tree_black;</span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                x = x-&gt;parent-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">                    x = x-&gt;parent;</span><br><span class="line">                    __rb_tree_rotate_right(x, root);</span><br><span class="line">                &#125;</span><br><span class="line">                x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">                x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">                __rb_tree_rotate_left(x-&gt;parent-&gt;parent, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;color = __rb_tree_black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__rb_tree_rotate_left(base_ptr x, base_ptr&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">    base_ptr y = x-&gt;right;</span><br><span class="line">    x-&gt;right = y-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == root)</span><br><span class="line">        root = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__rb_tree_rotate_right(base_ptr x, base_ptr&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">    base_ptr y = x-&gt;left;</span><br><span class="line">    x-&gt;left = y-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (y-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">        y-&gt;right-&gt;parent = x;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == root)</span><br><span class="line">        root = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)</span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    y-&gt;right = x;</span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; k) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k))</span><br><span class="line">            y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    iterator j = <span class="built_in">iterator</span>(y);</span><br><span class="line">    <span class="keyword">return</span> (j == <span class="built_in">end</span>() <span class="keyword">or</span> <span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(j.node)) ? <span class="built_in">end</span>() : j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> Key&amp; k) <span class="type">const</span> -&gt; const_iterator</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k))</span><br><span class="line">            y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    iterator j = <span class="built_in">const_iterator</span>(y);</span><br><span class="line">    <span class="keyword">return</span> (j == <span class="built_in">end</span>() <span class="keyword">or</span> <span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(j.node)) ? <span class="built_in">end</span>() : j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__erase(link_type x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    __erase(<span class="built_in">left</span>(x));</span><br><span class="line">    __erase(<span class="built_in">right</span>(x));</span><br><span class="line">    <span class="built_in">destroy_node</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __erase(<span class="built_in">root</span>());</span><br><span class="line">    <span class="built_in">left</span>(header) = header;</span><br><span class="line">    <span class="built_in">right</span>(header) = header;</span><br><span class="line">    <span class="built_in">parent</span>(header) = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">erase</span>(iterator position)</span><br><span class="line">&#123;</span><br><span class="line">	base_ptr to_be_delete = <span class="built_in">rbtree_rebalance_erase</span>(position.node, <span class="built_in">root</span>());</span><br><span class="line">	<span class="built_in">destroy_node</span>((link_type)to_be_delete);</span><br><span class="line">	node_count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">erase</span>(<span class="type">const</span> Key&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">	iterator position = <span class="built_in">find</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (position == <span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    base_ptr to_be_delete = __rb_tree_rebalance_erase(position.node, (base_ptr&amp;)<span class="built_in">root</span>());</span><br><span class="line">	<span class="built_in">destroy_node</span>((link_type)to_be_delete);</span><br><span class="line">	node_count--;</span><br><span class="line">    position = <span class="built_in">find</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__rb_tree_rebalance_erase(base_ptr z, base_ptr&amp; root) -&gt; base_ptr</span><br><span class="line">&#123;</span><br><span class="line">	base_ptr del_node = z;</span><br><span class="line">	base_ptr replace_node = <span class="literal">nullptr</span>;</span><br><span class="line">	base_ptr replace_node_parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (del_node-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">		replace_node = del_node-&gt;right;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (del_node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">		replace_node = del_node-&gt;left;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		del_node = del_node-&gt;right;</span><br><span class="line">		<span class="keyword">while</span> (del_node-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">			del_node = del_node-&gt;left;</span><br><span class="line">		replace_node = del_node-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (del_node == z)</span><br><span class="line">	&#123;</span><br><span class="line">		replace_node_parent = del_node-&gt;parent;</span><br><span class="line">		<span class="keyword">if</span> (z == root)</span><br><span class="line">			root = replace_node;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (z == z-&gt;parent-&gt;left)</span><br><span class="line">			z-&gt;parent-&gt;left = replace_node;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			z-&gt;parent-&gt;right = replace_node;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (replace_node != <span class="literal">nullptr</span>)</span><br><span class="line">            replace_node-&gt;parent = z-&gt;parent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (z == <span class="built_in">leftmost</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (z-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">				<span class="built_in">leftmost</span>() = (link_type)z-&gt;parent;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">leftmost</span>() = <span class="built_in">minimum</span>((link_type)replace_node);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (z == <span class="built_in">rightmost</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (z-&gt;left == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">rightmost</span>() = (link_type)z-&gt;parent;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">rightmost</span>() = <span class="built_in">maximum</span>((link_type)replace_node);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		del_node-&gt;left = z-&gt;left;</span><br><span class="line">		z-&gt;left-&gt;parent = del_node;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (z-&gt;right != del_node)</span><br><span class="line">		&#123;</span><br><span class="line">			replace_node_parent = del_node-&gt;parent;</span><br><span class="line">			<span class="keyword">if</span> (replace_node != <span class="literal">nullptr</span>) </span><br><span class="line">				replace_node-&gt;parent = del_node-&gt;parent;</span><br><span class="line">			del_node-&gt;parent-&gt;left = replace_node;</span><br><span class="line"></span><br><span class="line">			del_node-&gt;right = z-&gt;right;</span><br><span class="line">			z-&gt;right-&gt;parent = del_node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			replace_node_parent = del_node;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (z == root)</span><br><span class="line">			root = del_node;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (z == z-&gt;parent-&gt;left)</span><br><span class="line">			z-&gt;parent-&gt;left = del_node;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			z-&gt;parent-&gt;right = del_node;</span><br><span class="line">		del_node-&gt;parent = z-&gt;parent;</span><br><span class="line"></span><br><span class="line">		std::<span class="built_in">swap</span>(del_node-&gt;color, z-&gt;color);</span><br><span class="line">		del_node = z;	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (del_node-&gt;color == __rb_tree_red)</span><br><span class="line">        <span class="keyword">return</span> del_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (replace_node != root <span class="built_in">and</span> (!replace_node <span class="keyword">or</span> replace_node-&gt;color == __rb_tree_black))  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (replace_node == replace_node_parent-&gt;left)</span><br><span class="line">		&#123;</span><br><span class="line">			base_ptr s = replace_node_parent-&gt;right;</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;color == __rb_tree_red)</span><br><span class="line">			&#123;</span><br><span class="line">				s-&gt;color = __rb_tree_black;</span><br><span class="line">				replace_node_parent-&gt;color = __rb_tree_red;</span><br><span class="line">				__rb_tree_rotate_left(replace_node_parent, root);</span><br><span class="line">				s = replace_node_parent-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((!s-&gt;left <span class="keyword">or</span> s-&gt;left-&gt;color == __rb_tree_black) <span class="built_in">and</span></span><br><span class="line">				(!s-&gt;right <span class="keyword">or</span> s-&gt;right-&gt;color == __rb_tree_black))</span><br><span class="line">			&#123;</span><br><span class="line">				s-&gt;color = __rb_tree_red;</span><br><span class="line">				replace_node = replace_node_parent;</span><br><span class="line">				replace_node_parent = replace_node_parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!s-&gt;right <span class="keyword">or</span> s-&gt;right-&gt;color == __rb_tree_black)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (s-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">						s-&gt;left-&gt;color = __rb_tree_black;</span><br><span class="line">					s-&gt;right-&gt;color = __rb_tree_red;</span><br><span class="line">                    __rb_tree_rotate_right(s, root);</span><br><span class="line">					s = replace_node_parent-&gt;right;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				s-&gt;color = replace_node_parent-&gt;color;</span><br><span class="line">				replace_node_parent-&gt;color = __rb_tree_black;</span><br><span class="line">				<span class="keyword">if</span> (s-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">					s-&gt;right-&gt;color = __rb_tree_black;</span><br><span class="line">				__rb_tree_rotate_left(replace_node_parent, root);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			base_ptr s = replace_node_parent-&gt;left;</span><br><span class="line">			<span class="keyword">if</span> (s-&gt;color == __rb_tree_red)</span><br><span class="line">			&#123;</span><br><span class="line">				s-&gt;color = __rb_tree_black;</span><br><span class="line">				replace_node_parent-&gt;color = __rb_tree_red;</span><br><span class="line">				__rb_tree_rotate_right(replace_node_parent, root);</span><br><span class="line">				s = replace_node_parent-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((!s-&gt;left <span class="keyword">or</span> s-&gt;left-&gt;color == __rb_tree_black) <span class="built_in">and</span></span><br><span class="line">				(!s-&gt;right <span class="keyword">or</span> s-&gt;right-&gt;color == __rb_tree_black))</span><br><span class="line">			&#123;</span><br><span class="line">				s-&gt;color = __rb_tree_red;</span><br><span class="line">				replace_node = replace_node_parent;</span><br><span class="line">				replace_node_parent = replace_node_parent-&gt;parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!s-&gt;left <span class="keyword">or</span> s-&gt;left-&gt;color == __rb_tree_black)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (s-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">						s-&gt;right-&gt;color = __rb_tree_black;</span><br><span class="line">					s-&gt;color = __rb_tree_red;</span><br><span class="line">					__rb_tree_rotate_left(s, root);</span><br><span class="line">					s = replace_node_parent-&gt;left;</span><br><span class="line">				&#125;</span><br><span class="line">				s-&gt;color = replace_node_parent-&gt;color;</span><br><span class="line">				replace_node_parent-&gt;color = __rb_tree_black;</span><br><span class="line">				<span class="keyword">if</span> (s-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">					s-&gt;left-&gt;color = __rb_tree_black;</span><br><span class="line">				__rb_tree_rotate_right(replace_node_parent, root);</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (replace_node != <span class="literal">nullptr</span>) </span><br><span class="line">        replace_node-&gt;color = __rb_tree_black;</span><br><span class="line">	<span class="keyword">return</span> del_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">lower_bound</span>(<span class="type">const</span> Key&amp; k) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k))</span><br><span class="line">            y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">lower_bound</span>(<span class="type">const</span> Key&amp; k) <span class="type">const</span> -&gt; const_iterator</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k))</span><br><span class="line">            y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">upper_bound</span>(<span class="type">const</span> Key&amp; k) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(x)))</span><br><span class="line">            y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">iterator</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> KeyOfValue, <span class="keyword">typename</span> Compare, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">upper_bound</span>(<span class="type">const</span> Key&amp; k) <span class="type">const</span> -&gt; const_iterator</span><br><span class="line">&#123;</span><br><span class="line">    link_type y = header;</span><br><span class="line">    link_type x = <span class="built_in">root</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(x)))</span><br><span class="line">            y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = <span class="built_in">right</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_cpp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Tiny;</span><br><span class="line"><span class="keyword">using</span> tree = rb_tree&lt;<span class="type">int</span>, <span class="type">int</span>, Comp, std::less&lt;<span class="type">int</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> tree&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size = &quot;</span> &lt;&lt; t.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = t.<span class="built_in">begin</span>(); it != t.<span class="built_in">end</span>(); it++)</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree t;</span><br><span class="line">    </span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">13</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">erase</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">erase</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_unique</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">insert_equal</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">    t.<span class="built_in">erase</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">show</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 4-2：红黑树的应用</title>
    <url>/2024/09/06/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%974-2/</url>
    <content><![CDATA[<p>在上次的红黑树 RB-Tree 的基础上，可以实现以下四个 container：</p>
<ul>
<li>set：其各个元素的键与值完全相同，且必须是唯一的，且默认进行升序排序。</li>
<li>map：其各个元素的键唯一，且默认根据其键的大小进行升序排序。</li>
<li>multiset：与 set 大致相同，但允许重复的键出现。</li>
<li>multimap：与 map 大致相同，但允许重复的键出现。</li>
</ul>
<p>虽然都是集合，但刻意划分出 set 与 map 的区别是为了满足 STL
的设计理念。简单来说，set 允许通过其元素整体的大小排序，而 map
允许通过其元素一部分的大小排序；set 不允许通过迭代器修改其元素，而 map
允许通过迭代器部分修改其元素。只要使用得当，红黑树的所有应用场景都能覆盖，不得不佩服设计者的巧思。</p>
<p>也是因为覆盖了所有的场景，我们的设计需要更加谨慎，尤其是涉及 const
方法时。rb_tree
显著降低了设计的心智负担（但如果完全按照《STL源码剖析》甚至无法通过编译），以下是源代码。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_set.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waiting for less&lt;&gt;, forward&lt;&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_functional.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Compare = std::less&lt;Key&gt;, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> value_type = Key;</span><br><span class="line">    <span class="keyword">using</span> key_compare = Compare;</span><br><span class="line">    <span class="keyword">using</span> value_compare = Compare;</span><br><span class="line">    <span class="keyword">using</span> self = set&lt;Key, Compare, Alloc&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> rep_type = rb_tree&lt;key_type, value_type, identity&lt;value_type&gt;, key_compare, Alloc&gt;;</span><br><span class="line">    rep_type t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> rep_type::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> const_pointer = <span class="keyword">typename</span> rep_type::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">typename</span> rep_type::const_reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> rep_type::const_reference;</span><br><span class="line">    <span class="keyword">using</span> iterator = <span class="keyword">typename</span> rep_type::const_iterator;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = <span class="keyword">typename</span> rep_type::const_iterator;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">typename</span> rep_type::size_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> rep_type::difference_type;    </span><br><span class="line">    <span class="built_in">set</span>() : <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">set</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp) &#123;</span> &#125;</span><br><span class="line">    <span class="built_in">set</span>(<span class="type">const</span> self&amp; x) : <span class="built_in">t</span>(x.t) &#123; &#125;</span><br><span class="line">    <span class="built_in">set</span>(self&amp;&amp; x) : <span class="built_in">t</span>(x.t) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>=(<span class="type">const</span> self&amp; x)  &#123; t = x.t; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> size_type <span class="title">max_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep_type::<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(self&amp; x)</span> </span>&#123; t.<span class="built_in">swap</span>(x.t); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> pair_iterator_bool = std::pair&lt;iterator, <span class="type">bool</span>&gt;;</span><br><span class="line">    <span class="function">pair_iterator_bool <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">count</span>(x); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_map.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waiting for less&lt;&gt;, binary_function&lt;&gt;, _Select1st&lt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = std::less&lt;Key&gt;, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> data_type = T;</span><br><span class="line">    <span class="keyword">using</span> mapped_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = std::pair&lt;<span class="type">const</span> Key, T&gt;;</span><br><span class="line">    <span class="keyword">using</span> key_compare = Compare;</span><br><span class="line">    <span class="keyword">using</span> self = map&lt;Key, T, Compare, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">value_compare</span> : <span class="keyword">public</span> std::binary_function&lt;value_type, value_type, <span class="type">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>&lt;Key, T, Compare, Alloc&gt;;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Compare comp;</span><br><span class="line">        <span class="built_in">value_compare</span>(Compare c) : <span class="built_in">comp</span>(c) &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> value_type&amp; x, <span class="type">const</span> value_type&amp; y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">comp</span>(x.first, y.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> rep_type = rb_tree&lt;key_type, value_type, std::_Select1st&lt;value_type&gt;, key_compare, Alloc&gt;;</span><br><span class="line">    rep_type t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> rep_type::pointer;</span><br><span class="line">    <span class="keyword">using</span> const_pouinter = <span class="keyword">typename</span> rep_type::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">typename</span> rep_type::reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> rep_type::const_reference;</span><br><span class="line">    <span class="keyword">using</span> iterator = <span class="keyword">typename</span> rep_type::iterator;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = <span class="keyword">typename</span> rep_type::const_iterator;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">typename</span> rep_type::size_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> rep_type::difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>() : <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">map</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp) &#123;</span> &#125;</span><br><span class="line">    <span class="built_in">map</span>(<span class="type">const</span> self&amp; x) : <span class="built_in">t</span>(x.t) &#123; &#125;</span><br><span class="line">    <span class="built_in">map</span>(self&amp;&amp; x) : <span class="built_in">t</span>(x.t) &#123; &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>=(<span class="type">const</span> self&amp; x) &#123; t = x.t; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">value_compare</span>(t.<span class="built_in">key_comp</span>()); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> size_type <span class="title">max_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep_type::<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>())).first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(self&amp; x)</span> </span>&#123; t.<span class="built_in">swap</span>(x.t); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> pair_iterator_bool = std::pair&lt;iterator, <span class="type">bool</span>&gt;;</span><br><span class="line">    <span class="function">pair_iterator_bool <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_unique</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">count</span>(x); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_multiset.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waiting for less&lt;&gt;, forward&lt;&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_tree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_functional.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Compare = std::less&lt;Key&gt;, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> multiset</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> value_type = Key;</span><br><span class="line">    <span class="keyword">using</span> key_compare = Compare;</span><br><span class="line">    <span class="keyword">using</span> value_compare = Compare;</span><br><span class="line">    <span class="keyword">using</span> self = multiset&lt;Key, Compare, Alloc&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> rep_type = rb_tree&lt;key_type, value_type, identity&lt;value_type&gt;, key_compare, Alloc&gt;;</span><br><span class="line">    rep_type t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> rep_type::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> const_pointer = <span class="keyword">typename</span> rep_type::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">typename</span> rep_type::const_reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> rep_type::const_reference;</span><br><span class="line">    <span class="keyword">using</span> iterator = <span class="keyword">typename</span> rep_type::const_iterator;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = <span class="keyword">typename</span> rep_type::const_iterator;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">typename</span> rep_type::size_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> rep_type::difference_type;    </span><br><span class="line">    <span class="built_in">multiset</span>() : <span class="built_in">t</span>(<span class="built_in">Compare</span>()) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">multiset</span><span class="params">(<span class="type">const</span> Compare&amp; comp)</span> : t(comp) &#123;</span> &#125;</span><br><span class="line">    <span class="built_in">multiset</span>(<span class="type">const</span> self&amp; x) : <span class="built_in">t</span>(x.t) &#123; &#125;</span><br><span class="line">    <span class="built_in">multiset</span>(self&amp;&amp; x) : <span class="built_in">t</span>(x.t) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>=(<span class="type">const</span> self&amp; x)  &#123; t = x.t; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function">key_compare <span class="title">key_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">    <span class="function">value_compare <span class="title">value_comp</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">key_comp</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> size_type <span class="title">max_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep_type::<span class="built_in">max_size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(self&amp; x)</span> </span>&#123; t.<span class="built_in">swap</span>(x.t); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">insert_equal</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">        t.<span class="built_in">erase</span>(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">erase</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; t.<span class="built_in">clear</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">find</span>(x); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> t.<span class="built_in">count</span>(x); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> key_type&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="type">const</span> key_type x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_multimap.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_multimap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tiny::multimap&lt;std::string, <span class="type">int</span>&gt; h;</span><br><span class="line">    h[<span class="string">&quot;jjhou&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">    h[<span class="string">&quot;jerry&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    h[<span class="string">&quot;jason&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">    h[<span class="string">&quot;jimmy&quot;</span>] = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="string">&quot;jason&quot;</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    h.<span class="built_in">insert</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = h.<span class="built_in">begin</span>(); it != h.<span class="built_in">end</span>(); it++)</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> num = h[<span class="string">&quot;jjhou&quot;</span>];</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = h.<span class="built_in">find</span>(<span class="string">&quot;mchen&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it == h.<span class="built_in">end</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;mchen not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    it = h.<span class="built_in">find</span>(<span class="string">&quot;jason&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != h.<span class="built_in">end</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;jason found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    it-&gt;second = <span class="number">9</span>;</span><br><span class="line">    num = h[<span class="string">&quot;jason&quot;</span>];</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 4-3：哈希表 hashtable</title>
    <url>/2024/09/09/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%974-3/</url>
    <content><![CDATA[<p>哈希表 hashtable 提供了一种不同于红黑树 rb_tree 的关联式容器。如果以
Acmer 的角度简单分析其优劣，hashtable
牺牲了元素的有序，用更大的空间占用换取了常数级的查询、插入、删除操作，且实现起来更加简单。</p>
<p>既然两种容器各有优劣，那没理由不去都实现一遍。哈希表的原理自不必说，只要
tiny_hash_fun.h 头文件中有定义 hash<T>，或用户自己实现了
hash<T>，那么类型 T 就可以用 hashtable 维护。另外，STL
中的哈希表使用开链法处理哈希冲突，当元素数量超过桶的数量时，自动重新整理整个哈希表。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num_primes = <span class="number">28</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> prime_list[num_primes] = &#123;</span><br><span class="line">    <span class="number">53</span>, <span class="number">97</span>, <span class="number">193</span>, <span class="number">389</span>, <span class="number">769</span>,</span><br><span class="line">    <span class="number">1543</span>, <span class="number">3079</span>, <span class="number">6151</span>, <span class="number">12289</span>, <span class="number">24593</span>,</span><br><span class="line">    <span class="number">49157</span>, <span class="number">98317</span>, <span class="number">196613</span>, <span class="number">393241</span>, <span class="number">786433</span>,</span><br><span class="line">    <span class="number">1572869</span>, <span class="number">3145739</span>, <span class="number">6291469</span>, <span class="number">12582917</span>, <span class="number">25165843</span>,</span><br><span class="line">    <span class="number">50331653</span>, <span class="number">100663319</span>, <span class="number">201326611</span>, <span class="number">402653189</span>, <span class="number">805306457</span>,</span><br><span class="line">    <span class="number">1610612741</span>, <span class="number">3221225473u</span>, <span class="number">4294967291u</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> node = __hashtable_node&lt;Value&gt;;</span><br><span class="line">    node* next;</span><br><span class="line">    Value val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn,</span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> hashtable = hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> node = __hashtable_node&lt;Value&gt;;</span><br><span class="line">    <span class="keyword">using</span> self = __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> iterator_category = forward_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = Value;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> reference = Value&amp;;</span><br><span class="line">    <span class="keyword">using</span> pointer = Value*;</span><br><span class="line"></span><br><span class="line">    node* cur;</span><br><span class="line">    hashtable* ht;</span><br><span class="line"></span><br><span class="line">    __hashtable_iterator() = <span class="keyword">default</span>;</span><br><span class="line">    __hashtable_iterator(node* n, hashtable* tab) : <span class="built_in">cur</span>(n), <span class="built_in">ht</span>(tab) &#123; &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(__hashtable_iterator it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(__hashtable_iterator it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> node* old = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        size_type buc = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (!cur <span class="keyword">and</span> ++buc &lt; ht-&gt;buckets.<span class="built_in">size</span>())</span><br><span class="line">            cur = ht-&gt;buckets[buc];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn,</span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__hashtable_const_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> hashtable = hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> node = __hashtable_node&lt;Value&gt;;</span><br><span class="line">    <span class="keyword">using</span> iterator = __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> self = __hashtable_const_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> iterator_category = forward_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type = Value;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="type">const</span> Value&amp;;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="type">const</span> Value*;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> node* cur;</span><br><span class="line">    <span class="type">const</span> hashtable* ht;</span><br><span class="line"></span><br><span class="line">    __hashtable_const_iterator() = <span class="keyword">default</span>;</span><br><span class="line">    __hashtable_const_iterator(iterator it) : <span class="built_in">cur</span>(it.cur), <span class="built_in">ht</span>(it.ht) &#123; &#125;</span><br><span class="line">    __hashtable_const_iterator(<span class="type">const</span> node* n, <span class="type">const</span> hashtable* tab) : <span class="built_in">cur</span>(n), <span class="built_in">ht</span>(tab) &#123; &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(__hashtable_const_iterator it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(__hashtable_const_iterator it) <span class="type">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> node* old = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        size_type buc = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">        <span class="keyword">while</span> (!cur <span class="keyword">and</span> ++buc &lt; ht-&gt;buckets.<span class="built_in">size</span>())</span><br><span class="line">            cur = ht-&gt;buckets[buc];</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hashtable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> hasher = HashFcn;</span><br><span class="line">    <span class="keyword">using</span> key_equal = EqualKey;</span><br><span class="line">    <span class="keyword">using</span> value_type = Value;</span><br><span class="line">    <span class="keyword">using</span> key_type = Key;</span><br><span class="line">    <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">    <span class="keyword">using</span> const_pointer = <span class="type">const</span> value_type*;</span><br><span class="line">    <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="type">const</span> value_type&amp;;</span><br><span class="line">    <span class="keyword">using</span> iterator = __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = __hashtable_const_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="type">ptrdiff_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">__hashtable_iterator</span>&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">__hashtable_const_iterator</span>&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    hasher hash;</span><br><span class="line">    key_equal equals;</span><br><span class="line">    ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> node = __hashtable_node&lt;Value&gt;;</span><br><span class="line">    <span class="keyword">using</span> node_allocator = simple_alloc&lt;node, Alloc&gt;;</span><br><span class="line">    vector&lt;node*, Alloc&gt; buckets;</span><br><span class="line">    size_type num_elements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">next_prime</span><span class="params">(<span class="type">unsigned</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span>* first = prime_list;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span>* last = prime_list + num_primes;</span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span>* pos = std::<span class="built_in">lower_bound</span>(first, last, n);</span><br><span class="line">        <span class="keyword">return</span> pos == last ? *(last - <span class="number">1</span>) : *pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hash; &#125;</span><br><span class="line">    <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> equals; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> prime_list[num_primes - <span class="number">1</span>]; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">next_size</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">next_prime</span>(n); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        size_type count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (node* cur = buckets[n]; cur; cur = cur-&gt;next)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">node* <span class="title">new_node</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* n = node_allocator::<span class="built_in">allocate</span>();</span><br><span class="line">        n-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">construct</span>(&amp;n-&gt;val, obj);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            node_allocator::<span class="built_in">deallocate</span>(n);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_node</span><span class="params">(node* n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">destroy</span>(&amp;n-&gt;val);</span><br><span class="line">        node_allocator::<span class="built_in">deallocate</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize_buckets</span><span class="params">(size_type n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> size_type n_buckets = <span class="built_in">next_size</span>(n);</span><br><span class="line">        buckets.<span class="built_in">reserve</span>(n_buckets);</span><br><span class="line">        buckets.<span class="built_in">assign</span>(n_buckets, <span class="literal">nullptr</span>);</span><br><span class="line">        num_elements = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj, size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj), n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(<span class="built_in">get_key</span>(obj));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bkt_num_key</span>(key, buckets.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bkt_num_key</span><span class="params">(<span class="type">const</span> key_type&amp; key, size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>(key) % n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (node* cur : buckets)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(cur, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> node* cur : buckets)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">const_iterator</span>(cur, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="literal">nullptr</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="literal">nullptr</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num_elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num_elements == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hashtable</span>(size_type n, <span class="type">const</span> hasher&amp; hf, <span class="type">const</span> key_equal&amp; eql)</span><br><span class="line">        : <span class="built_in">hash</span>(hf), <span class="built_in">equals</span>(eql), <span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()), <span class="built_in">num_elements</span>(<span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">initialize_buckets</span>(n); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">hashtable</span>(<span class="type">const</span> hashtable&amp; ht) </span><br><span class="line">        : <span class="built_in">hash</span>(ht.hash), <span class="built_in">equals</span>(ht.equals), <span class="built_in">get_key</span>(ht.get_key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">copy_from</span>(ht);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">hashtable</span>(hashtable&amp;&amp; ht) </span><br><span class="line">        : <span class="built_in">hash</span>(ht.hash), <span class="built_in">equals</span>(ht.equals), <span class="built_in">get_key</span>(ht.get_key)</span><br><span class="line">    &#123;</span><br><span class="line">        buckets.<span class="built_in">swap</span>(ht.buckets);</span><br><span class="line">        num_elements = ht.num_elements;</span><br><span class="line">        ht.buckets.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">hashtable</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">insert_unique_noresize</span><span class="params">(<span class="type">const</span> value_type&amp;)</span> -&gt; std::pair&lt;iterator, <span class="type">bool</span>&gt;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">insert_equal_noresize</span><span class="params">(<span class="type">const</span> value_type&amp;)</span> -&gt; iterator</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(hashtable&amp; ht)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(hash, ht.hash);</span><br><span class="line">        std::<span class="built_in">swap</span>(equals, ht.equals);</span><br><span class="line">        std::<span class="built_in">swap</span>(get_key, ht.get_key);</span><br><span class="line">        std::<span class="built_in">swap</span>(num_elements, ht.num_elements);</span><br><span class="line">        buckets.<span class="built_in">swap</span>(ht.buckets);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">insert_unique</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> -&gt; std::pair&lt;iterator, <span class="type">bool</span>&gt; </span>&#123;</span><br><span class="line">        <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">insert_equal</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> -&gt; iterator </span>&#123;</span><br><span class="line">        <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp;)</span> -&gt; size_type</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy_from</span><span class="params">(<span class="type">const</span> hashtable&amp;)</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp;)</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">resize</span>(size_type num_elements_hint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (num_elements_hint &lt;= old_n) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= old_n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="function">vector&lt;node*, Alloc&gt; <span class="title">tmp</span><span class="params">(n, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (size_type bucket = <span class="number">0</span>; bucket &lt; old_n; bucket++)</span><br><span class="line">    &#123;</span><br><span class="line">        node* first = buckets[bucket];</span><br><span class="line">        <span class="keyword">while</span> (first)</span><br><span class="line">        &#123;</span><br><span class="line">            size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val, n);</span><br><span class="line">            buckets[bucket] = first-&gt;next;</span><br><span class="line">            first-&gt;next = tmp[new_bucket];</span><br><span class="line">            tmp[new_bucket] = first;</span><br><span class="line">            first = buckets[bucket];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buckets.<span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">insert_unique_noresize</span>(<span class="type">const</span> value_type&amp; x) -&gt; std::pair&lt;iterator, <span class="type">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(x);</span><br><span class="line">    node* first = buckets[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(x)))</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>&#125;;</span><br><span class="line">    node* tmp = <span class="built_in">new_node</span>(x);</span><br><span class="line">    tmp-&gt;next = first;</span><br><span class="line">    buckets[n] = tmp;</span><br><span class="line">    ++num_elements;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>), <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">insert_equal_noresize</span>(<span class="type">const</span> value_type&amp; x) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(x);</span><br><span class="line">    node* first = buckets[n];</span><br><span class="line">    node* tmp = <span class="built_in">new_node</span>(x);</span><br><span class="line">    tmp-&gt;next = first;</span><br><span class="line">    buckets[n] = tmp;</span><br><span class="line">    num_elements++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">erase</span>(<span class="type">const</span> key_type&amp; key) -&gt; size_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">    node* first = buckets[n];</span><br><span class="line">    size_type erased = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!first) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    node* cur = first;</span><br><span class="line">    node* next = cur-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(next-&gt;val), key))</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">delete_node</span>(next);</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            erased++;</span><br><span class="line">            num_elements--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = next;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(first-&gt;val), key))</span><br><span class="line">    &#123;</span><br><span class="line">        buckets[n] = first-&gt;next;</span><br><span class="line">        <span class="built_in">delete_node</span>(first);</span><br><span class="line">        erased++;</span><br><span class="line">        num_elements--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> erased;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">erase</span>(iterator pos)</span><br><span class="line">&#123;</span><br><span class="line">    node* p = pos.cur;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> size_type n = <span class="built_in">bkt_num</span>(p-&gt;val);</span><br><span class="line">    node* cur = buckets[n];</span><br><span class="line">    <span class="keyword">if</span> (cur == p) &#123;</span><br><span class="line">        buckets[n] = cur-&gt;next;</span><br><span class="line">        <span class="built_in">delete_node</span>(cur);</span><br><span class="line">        num_elements--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node* next = cur-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (next == p) &#123;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            <span class="built_in">delete_node</span>(next);</span><br><span class="line">            num_elements--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (node* cur : buckets)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            node* next = cur-&gt;next;</span><br><span class="line">            <span class="built_in">delete_node</span>(cur);</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num_elements = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="type">void</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">copy_from</span>(<span class="type">const</span> hashtable&amp; ht)</span><br><span class="line">&#123;</span><br><span class="line">    size_type new_size = ht.buckets.<span class="built_in">size</span>();</span><br><span class="line">    buckets.<span class="built_in">clear</span>();</span><br><span class="line">    buckets.<span class="built_in">reserve</span>(new_size);</span><br><span class="line">    buckets.<span class="built_in">assign</span>(new_size, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; new_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> node* cur = ht.buckets[i];</span><br><span class="line">            <span class="keyword">if</span> (!cur) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">            buckets[i] = copy;</span><br><span class="line">            <span class="keyword">for</span> (node* next = cur-&gt;next; next; cur = next, next = cur-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">                copy = copy-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> key_type&amp; key) -&gt; iterator</span><br><span class="line">&#123;</span><br><span class="line">    size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">    node* first;</span><br><span class="line">    <span class="keyword">for</span> (first = buckets[n]; first; first = first-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(first-&gt;val), key))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(first, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">find</span>(<span class="type">const</span> key_type&amp; key) <span class="type">const</span> -&gt; const_iterator</span><br><span class="line">&#123;</span><br><span class="line">    size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">    node* first;</span><br><span class="line">    <span class="keyword">for</span> (first = buckets[n]; first; first = first-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(first-&gt;val), key))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_iterator</span>(first, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> Key, <span class="keyword">typename</span> HashFcn, </span><br><span class="line">        <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> EqualKey, <span class="keyword">typename</span> Alloc&gt;</span><br><span class="line"><span class="keyword">auto</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;::<span class="built_in">count</span>(<span class="type">const</span> key_type&amp; key) <span class="type">const</span> -&gt; size_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">    size_type result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> node* cur = buckets[n]; cur; cur = cur-&gt;next)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), key))</span><br><span class="line">            result++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL 开发日志 4-4：哈希表的应用</title>
    <url>/2024/09/11/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%974-4/</url>
    <content><![CDATA[<p>unordered_map 和 unordered_set 使用率并不亚于 map 和
set。就像上次我们分析的，unordered_set 通过其元素整体计算哈希值，而 map
允许通过其元素一部分计算哈希值；set 不允许通过迭代器修改其元素，而 map
允许通过迭代器部分修改其元素。</p>
<p>由于这两种容器与之前很相像，需要调整的部分大同小异，再加上 hashtable
异常高的效率，本次开发非常轻松。这是 C++11
标准中最后两个关联式容器，接下来对 container
的开发会告一段落，注意力转向 functional、adapter
以及算法部分，敬请期待：）</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_unordered_set.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_hashtable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_hash_fun.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value, <span class="keyword">typename</span> HashFcn = hash&lt;Value&gt;, </span><br><span class="line">        <span class="keyword">typename</span> EqualKey = std::equal_to&lt;Value&gt;, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> unordered_set</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> ht = hashtable&lt;Value, Value, HashFcn, std::_Identity&lt;Value&gt;, EqualKey, Alloc&gt;;</span><br><span class="line">    ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> key_type = <span class="keyword">typename</span> ht::key_type;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> ht::value_type;</span><br><span class="line">    <span class="keyword">using</span> hasher = <span class="keyword">typename</span> ht::hasher;</span><br><span class="line">    <span class="keyword">using</span> key_equal = <span class="keyword">typename</span> ht::key_equal;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">typename</span> ht::size_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> ht::difference_type;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> ht::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> const_pointer = <span class="keyword">typename</span> ht::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">typename</span> ht::const_reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> ht::const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> iterator = <span class="keyword">typename</span> ht::const_iterator;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = <span class="keyword">typename</span> ht::const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">    <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>(size_type n = <span class="number">50</span>, <span class="type">const</span> hasher&amp; hf = <span class="built_in">hasher</span>(), </span><br><span class="line">                  <span class="type">const</span> key_equal&amp; eql = <span class="built_in">key_equal</span>()) : <span class="built_in">rep</span>(n, hf, eql) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unordered_set&amp; h)</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">swap</span>(h.rep); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert_noresize</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">find</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">count</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rep.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123;</span><br><span class="line">        rep.<span class="built_in">resize</span>(hint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tiny_unordered_map.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_hashtable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tiny_hash_fun.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tiny</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashFcn = hash&lt;Key&gt;,</span><br><span class="line">        <span class="keyword">typename</span> EqualKey = std::equal_to&lt;Key&gt;, <span class="keyword">typename</span> Alloc = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> unordered_map</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> ht = hashtable&lt;std::pair&lt;<span class="type">const</span> Key, T&gt;, Key, HashFcn,</span><br><span class="line">            std::_Select1st&lt;std::pair&lt;<span class="type">const</span> Key, T&gt;&gt;, EqualKey, Alloc&gt;;</span><br><span class="line">    ht rep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> data_type = T;</span><br><span class="line">    <span class="keyword">using</span> mapped_type = T;</span><br><span class="line">    <span class="keyword">using</span> key_type = <span class="keyword">typename</span> ht::key_type;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> ht::value_type;</span><br><span class="line">    <span class="keyword">using</span> hasher = <span class="keyword">typename</span> ht::hasher;</span><br><span class="line">    <span class="keyword">using</span> key_equal = <span class="keyword">typename</span> ht::key_equal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> size_type = <span class="keyword">typename</span> ht::size_type;</span><br><span class="line">    <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> ht::difference_type;</span><br><span class="line">    <span class="keyword">using</span> pointer = <span class="keyword">typename</span> ht::pointer;</span><br><span class="line">    <span class="keyword">using</span> const_pointer = <span class="keyword">typename</span> ht::const_pointer;</span><br><span class="line">    <span class="keyword">using</span> reference = <span class="keyword">typename</span> ht::reference;</span><br><span class="line">    <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> ht::const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> iterator = <span class="keyword">typename</span> ht::iterator;</span><br><span class="line">    <span class="keyword">using</span> const_iterator = <span class="keyword">typename</span> ht::const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">hash_funct</span>(); &#125;</span><br><span class="line">    <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">key_eq</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>(size_type n = <span class="number">50</span>, <span class="type">const</span> hasher&amp; hf = <span class="built_in">hasher</span>(),</span><br><span class="line">                  <span class="type">const</span> key_equal&amp; eql = <span class="built_in">key_equal</span>()) : <span class="built_in">rep</span>(n, hf, eql) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unordered_map&amp; h)</span> </span>&#123; rep.<span class="built_in">swap</span>(h.rep); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">find</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">find</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">count</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">count</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; key) &#123;</span><br><span class="line">        iterator it = rep.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != rep.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">insert_unique</span>(&#123;key, <span class="built_in">T</span>()&#125;).first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rep.<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator it)</span> </span>&#123;</span><br><span class="line">        rep.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rep.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type hint)</span> </span>&#123; rep.<span class="built_in">resize</span>(hint); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">bucket_count</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">max_bucket_count</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type n)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> rep.<span class="built_in">elems_in_bucket</span>(n); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Khyal&#39;s TinySTL</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
</search>
